{"pageProps":{"postContent":[{"type":"paragraph","children":[{"type":"plain","text":"在數年的醞釀以及一時的心血來潮以後，我開始第一次真正投入時間學習 Unity 。至今一週，最大的感想是過往兩年自學程式的經驗惠我良多，但並不是因為程式的概念等，而是在尋找資源，搜尋關鍵字，看文件的速度上，比起兩三年前另一次摸 Unity 的時候有效率太多了。以下是這一週學到的我覺得值得筆記的部分。"}]},{"type":"heading","children":[{"type":"plain","text":"Object movement"}],"depth":1},{"type":"paragraph","children":[{"type":"plain","text":"在 Unity ，要讓一個物體移動有三種方式："}]},{"type":"list","ordered":false,"children":[{"type":"listItem","children":[{"type":"inlineCode","text":"Transform.position"}]},{"type":"listItem","children":[{"type":"inlineCode","text":"Rigidbody.AddForce()"}]},{"type":"listItem","children":[{"type":"inlineCode","text":"CharacterController.Move()"}]}]},{"type":"heading","children":[{"type":"plain","text":"Transform.position"}],"depth":2},{"type":"paragraph","children":[{"type":"inlineCode","text":"Transform"},{"type":"plain","text":" 是每個 gameObject 都有的屬性，掌管了物體的位置 (position)，角度 (rotation) 與大小 (scale) 。這三個屬性都具有 x, y, z 三個子屬性，對 position 你可以使用三維向量 (Vector3) ，對角度可以使用尤拉角 (Eular Angle) 來調整。"}]},{"type":"paragraph","children":[{"type":"plain","text":"使用 "},{"type":"inlineCode","text":"Transform.position"},{"type":"plain","text":" 調整物體位置的語法像是這樣："}]},{"type":"code","lang":"csharp","text":"Transform.position = new Vector3(0, 0, 1);"},{"type":"paragraph","children":[{"type":"plain","text":"在這裡，Vector3 裡面的數字都是整個遊戲地圖裡的絕對值，所以如果想基於物體位置進行移動，必須把物體當前位置也輸入進去。"}]},{"type":"code","lang":"csharp","text":"Vector3 objectPos = Transform.position;\nTransform.position = new Vector3(objetPos.x, objectPos.y, objectPos.z + 1);"},{"type":"paragraph","children":[{"type":"plain","text":"這樣就能讓物體朝向 Z 方向移動 1 單位。"}]},{"type":"paragraph","children":[{"type":"plain","text":"使用 "},{"type":"inlineCode","text":"Transform.position"},{"type":"plain","text":" 是強制調整物體位置，有點像是瞬間移動。適合的場合有攝影機等。"}]},{"type":"heading","children":[{"type":"plain","text":"Rigidbody.Addforce"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"來看看官方說明手冊的對 Rigidbody 的第一句說明："}]},{"type":"quote","children":[{"type":"plain","text":"Control of an object's position through physics simulation."}]},{"type":"paragraph","children":[{"type":"plain","text":"Rigidbody 是從物理面上控制物體。 "},{"type":"inlineCode","text":"AddForce"},{"type":"plain","text":" 就是基於一個 Vector3 的角度給予外力。"}]},{"type":"code","lang":"csharp","text":"Rigidbody.AddForce(new Vector3(0, 0, 10));"},{"type":"paragraph","children":[{"type":"plain","text":"這樣就會對該物體施加一股從 Z 方向來的大小為 10 的外力。"}]},{"type":"paragraph","children":[{"type":"plain","text":"由於 Rigidbody 是模擬物理，所以外力大小，物體質量等等都會影響物體最終位移距離。如果外力夠大，物體就會跟落葉一樣被吹飛。適合的場合有破壞場景物件等等。"}]},{"type":"heading","children":[{"type":"plain","text":"CharacterController.Move"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"一樣來看看官方手冊的說明："}]},{"type":"quote","children":[{"type":"plain","text":"A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody. A CharacterController is not affected by forces and will only move when you call the Move function. It will then carry out the movement but be constrained by collisions."}]},{"type":"paragraph","children":[{"type":"plain","text":"CharacterControll 是專為移動遊戲角色設計的，而不用使用外力或是瞬間移動的方式，能夠直接操控角色的移動。引數一樣是使用 Vector3 調整三個維度的移動幅度。"}]},{"type":"code","lang":"csharp","text":"CharacterController.Move(new Vector3(0, 0, 1));"},{"type":"paragraph","children":[{"type":"inlineCode","text":"CharacterController.Move"},{"type":"plain","text":" 比起 "},{"type":"inlineCode","text":"Rigidbody.AddForce"},{"type":"plain","text":" 更加平滑，且會受碰撞影響，比起 "},{"type":"inlineCode","text":"Transform.position"},{"type":"plain","text":" 更加自然。"}]},{"type":"paragraph","children":[{"type":"plain","text":"另外，值得注意的是有些動畫內建位移，若啟用 Root Motion 即使未使用任何移動函數仍然會移動物體，設計角色移動時必須將此一因素考慮進去。"}]},{"type":"heading","children":[{"type":"plain","text":"Execution Order"}],"depth":1},{"type":"paragraph","children":[{"type":"plain","text":"Unity 新增 script 的初始範本都包含兩個函數： "},{"type":"inlineCode","text":"Start()"},{"type":"plain","text":" 與 "},{"type":"inlineCode","text":"Update()"},{"type":"plain","text":" 。這兩個函數都是腳本系統的核心之一。"}]},{"type":"heading","children":[{"type":"plain","text":"Start()"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"Start 會在 script 啟動後，Update 的第一個 frame 更新前被呼叫。整個腳本生命中只會被呼叫這一次。"}]},{"type":"heading","children":[{"type":"plain","text":"Update()"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"Update 會在每一幀 (frame) 都被呼叫一次。玩家指令，角色移動等等都可以在這之中執行循環確認。但每一幀呼叫一次有一個問題，這代表 Update() 的呼叫頻率受客戶端的幀數影響，規格好幀數高呼叫次數就多，規格差呼叫次數就少，這將在玩家之間造成不平衡。"}]},{"type":"heading","children":[{"type":"plain","text":"FixedUpdate()"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"FixedUpdate 呼叫次數比 Update 高，且不綁定幀數，如果客戶端幀數低， FixedUpdate 可能在一幀之中呼叫數次，相反地若客戶端幀數高， FixedUpdate 也可能一幀呼叫不到一次。所有物理模擬與運算都會在 FixedUpdate 結束後立刻發生。"}]},{"type":"heading","children":[{"type":"plain","text":"LateUpdate()"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"LateUpdate() 會在 Update() 結束後被呼叫，所以也是一幀一次。LateUpdate() 被呼叫時， Update() 的運算已經全數完成。常見的使用場合是計算攝影機位置，能夠保證在角色完成移動後，攝影機才移動到需要的位置。"}]},{"type":"heading","children":[{"type":"plain","text":"Hitbox and hurtbox"}],"depth":1},{"type":"paragraph","children":[{"type":"plain","text":"3D 遊戲不可避免的就是 hitbox 與 hurtbox 的計算。這個功能可以使用 "},{"type":"inlineCode","text":"Physics.OverlapBox()"},{"type":"plain","text":" 達成。這個函數的功用是指定一個中心點與三維距離所建構的立方體，尋找所有進入這個立方體的其他碰撞體 (Collider)。更甚還可以指定 Layer ，將判斷對象限定在特定 Layer 。"}]},{"type":"paragraph","children":[{"type":"plain","text":"首先給想要賦予 Hitbox 的物體，比如說角色的拳頭，增加一個 Collider ，然後勾選 "},{"type":"inlineCode","text":"Is Trigger"},{"type":"plain","text":" 。這個選項可以讓該 Collider 不會與其他 Collider 造成碰撞與物理位移，而只會偵測碰撞體之間的重疊並依此觸發事件。具體實作如下："}]},{"type":"code","lang":"csharp","text":"public class AttackController : MonoBehaviour\n{\n\t\tpublic Collider Hitbox;\n\t\tpublic int ATK;\n\t\tprivate List<GameObject> hitEnemies = new List<GameObject>();\n\t\t\t\n\t\tvoid Update()\n\t\t{\n        DetectAttack(Hitbox);\n\t\t}\n\t\t\n\t\tpublic void ClearHitEnemyList()\n\t\t{\n\t\t    hitEnemies.Clear();\n\t\t}\n\n\t\tvoid DetectAttack(Collider hitbox)\n\t\t{\n\t\t    Collider[] hurtboxes = Physics.OverlapBox(\n\t\t        hitbox.bounds.center, // 中心點\n\t\t        hitbox.bounds.extents, // 三維尺寸\n\t\t        hitbox.transform.rotation, // 三維角度\n\t\t        LayerMask.GetMask(\"{INSERT LAYER NAME}\") // 指定對象 layer\n\t\t    );\n\t\t    \n\t\t\t\t// hurtboxed 就是這次攻擊所有被註冊的受攻擊碰撞體\n\t\t    foreach (Collider hurtbox in hurtboxes)\n\t\t    {\n\t\t        GameObject enemy = hurtbox.gameObject;\n\t\t        if (!hitEnemies.Contains(enemy))\n\t\t        {\n\t\t            hitEnemies.Add(enemy);\n\t\t            enemy.doAnythingYouWant(...);\n\t\t        }\n\t\t    }\n\t\t}\n}"},{"type":"paragraph","children":[{"type":"plain","text":"我在這邊已經加入了對同一目標的重複判斷，因為 hitbox 與 hurtbox 在同一次攻擊內也可能重合複數次，使用一個 List 記錄目標並比對每次擊中的目標是否已在本次攻擊的目標列表裡。開始攻擊時呼叫 "},{"type":"inlineCode","text":"ClearHitEnemyList"},{"type":"plain","text":" 清空列表即可。"}]},{"type":"paragraph","children":[{"type":"plain","text":"最後的 "},{"type":"inlineCode","text":"enemy"},{"type":"plain","text":" 是受到攻擊的 collider 的父物件本身，如果該物件在受到攻擊時呼叫的腳本在該物件身上，等於要從攻擊角色的 hitbox 腳本呼叫另一個物件的腳本，可以使用 "},{"type":"inlineCode","text":".SendMessageUpwards(\"{INSERT FUNC NAME}\", {INSERT FUNC PARAM})"},{"type":"plain","text":" 。這個函數可以向上呼叫該腳本父物件的其他函數。"}]}],"postMetadata":{"id":"unity-dev-memo-1","title":"Unity Dev Memo (1)","description":"","category":"Game Development","tags":["Unity3D"],"publishDate":"2020-03-08","pathname":"unity-dev-memo-1"},"last5posts":[{"id":"site-patch-notes-2024-redesign","title":"Site Patch Notes: 2024 Redesign","description":"The 2024 redesign is finally here! I went on a journey of learning editorial design, and did an overhaul to this site's design, both functionality-wise and visual-wise.","category":"Meta","tags":[],"publishDate":"2024-08-18","pathname":"site-patch-notes-2024-redesign"},{"id":"a-peek-of-the-world","title":"A Peek of the World","description":"I went to Copenhagen and London for my honeymoon, the first trip to Europe in my life. Some memories keep staying on my mind and I have many thoughts about them.","category":"Life","tags":[],"publishDate":"2024-06-16","pathname":"a-peek-of-the-world"},{"id":"godot-essentials","title":"Godot Essentials","description":"The biggest lessons I learned in my first Godot project.","category":"Game Development","tags":[],"publishDate":"2024-04-21","pathname":"godot-essentials"},{"id":"4-years-reflection","title":"4 Years Reflection","description":"Another two years of life as a full-time developer has passed. Many things changed and many lessons learned. It's a perfect timing to look back and reflect.","category":"Life","tags":[],"publishDate":"2024-04-08","pathname":"4-years-reflection"},{"id":"improving-greatness","title":"Improving Greatness","description":"Breath of the Wild is one of the most impactful game in last decade. Yet for its successor, Nintendo built an even more polished version on an already magnificent fundamental.","category":"Gaming","tags":[],"publishDate":"2024-03-17","pathname":"improving-greatness"}],"categoryPosts":[{"id":"godot-essentials","title":"Godot Essentials","description":"The biggest lessons I learned in my first Godot project.","category":"Game Development","tags":[],"publishDate":"2024-04-21","pathname":"godot-essentials"},{"id":"first-game-jam-postmortem","title":"First Game Jam Postmortem","description":"I attended a game jam for the first time in my life. It was the best decision I made as an indie game developer in many years.","category":"Game Development","tags":[],"publishDate":"2023-05-23","pathname":"first-game-jam-postmortem"}],"categories":[{"name":"Meta","count":5},{"name":"Life","count":6},{"name":"Game Development","count":5},{"name":"Gaming","count":12},{"name":"League of Legends","count":8},{"name":"Web Development","count":4},{"name":"HKT48","count":4},{"name":"Programming","count":3},{"name":"Movie","count":2}]},"__N_SSG":true}
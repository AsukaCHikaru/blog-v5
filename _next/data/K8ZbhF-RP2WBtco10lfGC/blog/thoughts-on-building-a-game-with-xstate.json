{"pageProps":{"postContent":[{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"For the prototyping of "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"Project Fiddlesticks"}],"url":"https://grapegummygames.itch.io/project-fiddlesticks"},{"type":"textBody","style":"plain","value":", my latest indie game project, I used "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"React"}],"url":"https://react.dev"},{"type":"textBody","style":"plain","value":" and "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"XState"}],"url":"https://xstate.js.org/"},{"type":"textBody","style":"plain","value":" as the building blocks. Finite state machines are essential components in games, and for a few years I have heard a lot of good things about XState as a finite state machine library; this is my first time using it, and it lived up to its reputation. After finishing the prototype, I decided to write up my thoughts on using XState in game development."}]},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"Head first XState"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Below is an example of a basic state machine that represents the most basic behavior of a mob: it is "},{"type":"textBody","style":"code","value":"alive"},{"type":"textBody","style":"plain","value":" by default, loses "},{"type":"textBody","style":"code","value":"hp"},{"type":"textBody","style":"plain","value":" when taking "},{"type":"textBody","style":"code","value":"damage"},{"type":"textBody","style":"plain","value":", and enters "},{"type":"textBody","style":"code","value":"dead"},{"type":"textBody","style":"plain","value":" state if hp drops to zero."}]},{"type":"code","lang":"ts","body":"const mobStateMachine = setup({\n  types: {\n    context: {} as { hp: number; maxHp: number },\n    input: {} as { maxHp: number },\n    events: {} as { type: \"damage\"; damage: number },\n  },\n}).createMachine({\n  id: \"mobState\",\n  initial: \"alive\",\n  context: ({ input }) => ({\n    hp: input.maxHp,\n    maxHp: input.maxHp,\n  }),\n  states: {\n    alive: {\n      on: {\n        damage: {\n          target: \"hit\",\n          actions: assign({\n            hp: ({ context, event }) => Math.max(context.hp - event.damage, 0),\n          }),\n        },\n      },\n    },\n    hit: {\n      always: [\n        {\n          target: \"alive\",\n          guard: ({ context }) => context.hp > 0,\n        },\n        {\n          target: \"dead\",\n          guard: ({ context }) => context.hp === 0,\n        },\n      ],\n    },\n    dead: {\n      type: \"final\",\n    },\n  },\n});"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Such objects created by the "},{"type":"textBody","style":"code","value":"createMachine"},{"type":"textBody","style":"plain","value":" API function similarly to blueprints—describing how the state machine should work but not performing the work itself. The actual state machines that execute in the program are called "},{"type":"textBody","style":"strong","value":"actors"},{"type":"textBody","style":"plain","value":", which are instances created by the state machine factory."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"A working actor for above state machine model looks like this:"}]},{"type":"code","lang":"ts","body":"const mobActor = createActor(mobStateMachine, {\n  input: { maxHp: 5 },\n});\nmobActor.start();\n\nconsole.log(\"mob state:\", mobActor.getSnapshot().value); // \"mob state: alive\"\nconsole.log(\"mob hp:\", mobActor.getSnapshot().context.hp); // \"mob hp: 5\"\n\nmobActor.send({ type: \"damage\", damage: 3 });\n\nconsole.log(\"mob state:\", mobActor.getSnapshot().value); // \"mob state: alive\"\nconsole.log(\"mob hp:\", mobActor.getSnapshot().context.hp); // \"mob hp: 2\"\n\nmobActor.send({ type: \"damage\", damage: 3 });\n\nconsole.log(\"mob state:\", mobActor.getSnapshot().value); // \"mob state: dead\"\nconsole.log(\"mob hp:\", mobActor.getSnapshot().context.hp); // \"mob hp: 0\""},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"Robust, precise"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Writing entity behavior in XState is straightforward, and after getting a grasp of it, fast. The event-based transitions guarantees that all behavior changes are predictable and traceable, which significantly reduces the cognition load during development. The eventless transitions, such as "},{"type":"textBody","style":"code","value":"always"},{"type":"textBody","style":"plain","value":" or "},{"type":"textBody","style":"code","value":"after"},{"type":"textBody","style":"plain","value":", on the other hand, while demand more awareness, make it simple and natural for describing conversion states."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"XState provides abundant APIs, which enables creating the entire entity behavior in the state machine model, while exposing only the "},{"type":"textBody","style":"code","value":"send"},{"type":"textBody","style":"plain","value":" API, which listens to nothing but the intended events for the current state. The encapsulation of logics makes the state machine robust, which is perhaps my favorite part of XState."}]},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"Context-rich"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Finite state machine is the backbone of an entity, but in a real game, an entity is more than just its states. For a killable mob, unless all attacks are instant-deaths such as spikes in "},{"type":"textBody","style":"italic","value":"Mega Man"},{"type":"textBody","style":"plain","value":", a "},{"type":"textBody","style":"code","value":"hp"},{"type":"textBody","style":"plain","value":" property would be necessary."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"XState provides a "},{"type":"textBody","style":"strong","value":"contexts"},{"type":"textBody","style":"plain","value":" API to integrate properties that changes with state changes or cause state changes, in the state machine itself. This is the integral component that enables the creation of the entire behavior model in XState."}]},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"Solid hierarchy"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Some state machines are designed to interact with one another, whether as siblings or parent-child. XState has it covered with the "},{"type":"textBody","style":"code","value":"spawn"},{"type":"textBody","style":"plain","value":" API for vertical hierarchy, or the "},{"type":"textBody","style":"code","value":"system"},{"type":"textBody","style":"plain","value":" API for more general communication among actors. This feature further improves encapsulation by eliminating unnecessary event calls from the user side. It took me a while to comprehend how the actors are supposed to communicate, but the design assures safety and structure."}]},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"It reacts well"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"It might be easy to take it granted for libraries providing sufficient integration with React, but I really appreciate the native support for React from the "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"@xstate/react"}],"url":"https://stately.ai/docs/xstate-react"},{"type":"textBody","style":"plain","value":" package, which makes using XState in React a walk in the park."}]},{"type":"heading","level":1,"body":[{"type":"textBody","style":"plain","value":"Conclusion"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Creating a game with XState was enjoyable, and I plan to continue using it, possibly even for my future projects."}]}],"postMetadata":{"id":"thoughts-on-building-a-game-with-xstate","title":"Thoughts on Building a Game with XState","description":"After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.","category":"note","topic":"game development","tags":[],"publishDate":"2025-01-04","pathname":"thoughts-on-building-a-game-with-xstate"},"last5posts":[{"id":"observation-on-programming-with-ai","title":"Observation on Programming with AI","description":"I reckoned getting familiar with AI coding tools is necessary, tried some, and to my surprise, I turned out to be quite optimistic.","category":"essay","topic":"programming","tags":[],"publishDate":"2025-03-13","pathname":"observation-on-programming-with-ai"},{"id":"blogging-and-digital-gardening","title":"Blogging and Digital Gardening in the Social Platform and Generative AI Era","description":"I talk to myself about why bother writing at somewhere nobody comes.","category":"essay","topic":"life","tags":[],"publishDate":"2025-02-11","pathname":"blogging-and-digital-gardening"},{"id":"a-redemption-three-years-later","title":"A Redemption Three Years Later","description":"CD PROJEKT RED made a promise about Night City, which they broke. Three years later they had another attempt, and to me, it was their redemption.","category":"review","topic":"gaming","tags":[],"publishDate":"2025-01-13","pathname":"a-redemption-three-years-later"},{"id":"s14-recap","title":"S14 Recap","description":"I did not play a lot of league during 2024, but I had a few unforgettable moments nonetheless.","category":"retrospective","topic":"gaming","tags":[],"publishDate":"2025-01-07","pathname":"s14-recap"},{"id":"thoughts-on-building-a-game-with-xstate","title":"Thoughts on Building a Game with XState","description":"After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.","category":"note","topic":"game development","tags":[],"publishDate":"2025-01-04","pathname":"thoughts-on-building-a-game-with-xstate"}],"categoryPosts":[{"id":"godot-essentials","title":"Godot Essentials","description":"The biggest lessons I learned in my first Godot project.","category":"note","topic":"game development","tags":[],"publishDate":"2024-04-21","pathname":"godot-essentials"},{"id":"unity-dev-memo-2","title":"Unity Dev Memo (2)","description":"關於 Unity3D 內 raycast 的研究筆記。","category":"note","topic":"game development","tags":[],"publishDate":"2020-10-04","pathname":"unity-dev-memo-2"},{"id":"unity-dev-memo-1","title":"Unity Dev Memo (1)","description":"關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。","category":"note","topic":"game development","tags":[],"publishDate":"2020-03-08","pathname":"unity-dev-memo-1"},{"id":"a-rather-easy-way-to-implement-quicksort-in-js","title":"A Rather Easy Way to Implement Quicksort in JavaScript","description":"My attempt to implement quicksort.","category":"note","topic":"programming","tags":[],"publishDate":"2019-05-23","pathname":"a-rather-easy-way-to-implement-quicksort-in-js"}],"categories":[{"name":"essay","count":13},{"name":"review","count":15},{"name":"retrospective","count":15},{"name":"note","count":9},{"name":"research","count":3}]},"__N_SSG":true}
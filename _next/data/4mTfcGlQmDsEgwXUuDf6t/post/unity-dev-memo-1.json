{"pageProps":{"postContent":[{"type":"paragraph","children":[{"type":"text","value":"在數年的醞釀以及一時的心血來潮以後，我開始第一次真正投入時間學習 Unity 。至今一週，最大的感想是過往兩年自學程式的經驗惠我良多，但並不是因為程式的概念等，而是在尋找資源，搜尋關鍵字，看文件的速度上，比起兩三年前另一次摸 Unity 的時候有效率太多了。以下是這一週學到的我覺得值得筆記的部分。","position":{"start":{"line":11,"column":1,"offset":202},"end":{"line":11,"column":150,"offset":351}}}]},{"type":"heading","depth":1,"children":[{"type":"text","value":"Object movement","position":{"start":{"line":13,"column":3,"offset":355},"end":{"line":13,"column":18,"offset":370}}}]},{"type":"paragraph","children":[{"type":"text","value":"在 Unity ，要讓一個物體移動有三種方式：","position":{"start":{"line":15,"column":1,"offset":372},"end":{"line":15,"column":24,"offset":395}}}]},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"Transform.position","position":{"start":{"line":17,"column":3,"offset":399},"end":{"line":17,"column":23,"offset":419}}}],"position":{"start":{"line":17,"column":3,"offset":399},"end":{"line":17,"column":23,"offset":419}}}],"position":{"start":{"line":17,"column":1,"offset":397},"end":{"line":17,"column":23,"offset":419}}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"Rigidbody.AddForce()","position":{"start":{"line":18,"column":3,"offset":422},"end":{"line":18,"column":25,"offset":444}}}],"position":{"start":{"line":18,"column":3,"offset":422},"end":{"line":18,"column":25,"offset":444}}}],"position":{"start":{"line":18,"column":1,"offset":420},"end":{"line":18,"column":25,"offset":444}}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"inlineCode","value":"CharacterController.Move()","position":{"start":{"line":19,"column":3,"offset":447},"end":{"line":19,"column":31,"offset":475}}}],"position":{"start":{"line":19,"column":3,"offset":447},"end":{"line":19,"column":31,"offset":475}}}],"position":{"start":{"line":19,"column":1,"offset":445},"end":{"line":19,"column":31,"offset":475}}}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Transform.position","position":{"start":{"line":21,"column":4,"offset":480},"end":{"line":21,"column":22,"offset":498}}}]},{"type":"paragraph","children":[{"type":"inlineCode","value":"Transform","position":{"start":{"line":23,"column":1,"offset":500},"end":{"line":23,"column":12,"offset":511}}},{"type":"text","value":" 是每個 gameObject 都有的屬性，掌管了物體的位置 (position)，角度 (rotation) 與大小 (scale) 。這三個屬性都具有 x, y, z 三個子屬性，對 position 你可以使用三維向量 (Vector3) ，對角度可以使用尤拉角 (Eular Angle) 來調整。","position":{"start":{"line":23,"column":12,"offset":511},"end":{"line":23,"column":165,"offset":664}}}]},{"type":"paragraph","children":[{"type":"text","value":"使用 ","position":{"start":{"line":25,"column":1,"offset":666},"end":{"line":25,"column":4,"offset":669}}},{"type":"inlineCode","value":"Transform.position","position":{"start":{"line":25,"column":4,"offset":669},"end":{"line":25,"column":24,"offset":689}}},{"type":"text","value":" 調整物體位置的語法像是這樣：","position":{"start":{"line":25,"column":24,"offset":689},"end":{"line":25,"column":39,"offset":704}}}]},{"type":"code","lang":"csharp","meta":null,"value":"Transform.position = new Vector3(0, 0, 1);"},{"type":"paragraph","children":[{"type":"text","value":"在這裡，Vector3 裡面的數字都是整個遊戲地圖裡的絕對值，所以如果想基於物體位置進行移動，必須把物體當前位置也輸入進去。","position":{"start":{"line":31,"column":1,"offset":764},"end":{"line":31,"column":63,"offset":826}}}]},{"type":"code","lang":"csharp","meta":null,"value":"Vector3 objectPos = Transform.position;\nTransform.position = new Vector3(objetPos.x, objectPos.y, objectPos.z + 1);"},{"type":"paragraph","children":[{"type":"text","value":"這樣就能讓物體朝向 Z 方向移動 1 單位。","position":{"start":{"line":38,"column":1,"offset":959},"end":{"line":38,"column":23,"offset":981}}}]},{"type":"paragraph","children":[{"type":"text","value":"使用 ","position":{"start":{"line":40,"column":1,"offset":983},"end":{"line":40,"column":4,"offset":986}}},{"type":"inlineCode","value":"Transform.position","position":{"start":{"line":40,"column":4,"offset":986},"end":{"line":40,"column":24,"offset":1006}}},{"type":"text","value":" 是強制調整物體位置，有點像是瞬間移動。適合的場合有攝影機等。","position":{"start":{"line":40,"column":24,"offset":1006},"end":{"line":40,"column":55,"offset":1037}}}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Rigidbody.Addforce","position":{"start":{"line":42,"column":4,"offset":1042},"end":{"line":42,"column":22,"offset":1060}}}]},{"type":"paragraph","children":[{"type":"text","value":"來看看官方說明手冊的對 Rigidbody 的第一句說明：","position":{"start":{"line":44,"column":1,"offset":1062},"end":{"line":44,"column":30,"offset":1091}}}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"Control of an object's position through physics simulation.","position":{"start":{"line":46,"column":3,"offset":1095},"end":{"line":46,"column":62,"offset":1154}}}],"position":{"start":{"line":46,"column":3,"offset":1095},"end":{"line":46,"column":62,"offset":1154}}}]},{"type":"paragraph","children":[{"type":"text","value":"Rigidbody 是從物理面上控制物體。 ","position":{"start":{"line":48,"column":1,"offset":1156},"end":{"line":48,"column":23,"offset":1178}}},{"type":"inlineCode","value":"AddForce","position":{"start":{"line":48,"column":23,"offset":1178},"end":{"line":48,"column":33,"offset":1188}}},{"type":"text","value":" 就是基於一個 Vector3 的角度給予外力。","position":{"start":{"line":48,"column":33,"offset":1188},"end":{"line":48,"column":57,"offset":1212}}}]},{"type":"code","lang":"csharp","meta":null,"value":"Rigidbody.AddForce(new Vector3(0, 0, 10));"},{"type":"paragraph","children":[{"type":"text","value":"這樣就會對該物體施加一股從 Z 方向來的大小為 10 的外力。","position":{"start":{"line":54,"column":1,"offset":1272},"end":{"line":54,"column":32,"offset":1303}}}]},{"type":"paragraph","children":[{"type":"text","value":"由於 Rigidbody 是模擬物理，所以外力大小，物體質量等等都會影響物體最終位移距離。如果外力夠大，物體就會跟落葉一樣被吹飛。適合的場合有破壞場景物件等等。","position":{"start":{"line":56,"column":1,"offset":1305},"end":{"line":56,"column":81,"offset":1385}}}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"CharacterController.Move","position":{"start":{"line":58,"column":4,"offset":1390},"end":{"line":58,"column":28,"offset":1414}}}]},{"type":"paragraph","children":[{"type":"text","value":"一樣來看看官方手冊的說明：","position":{"start":{"line":60,"column":1,"offset":1416},"end":{"line":60,"column":14,"offset":1429}}}]},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody. A CharacterController is not affected by forces and will only move when you call the Move function. It will then carry out the movement but be constrained by collisions.","position":{"start":{"line":62,"column":3,"offset":1433},"end":{"line":62,"column":294,"offset":1724}}}],"position":{"start":{"line":62,"column":3,"offset":1433},"end":{"line":62,"column":294,"offset":1724}}}]},{"type":"paragraph","children":[{"type":"text","value":"CharacterControll 是專為移動遊戲角色設計的，而不用使用外力或是瞬間移動的方式，能夠直接操控角色的移動。引數一樣是使用 Vector3 調整三個維度的移動幅度。","position":{"start":{"line":64,"column":1,"offset":1726},"end":{"line":64,"column":89,"offset":1814}}}]},{"type":"code","lang":"csharp","meta":null,"value":"CharacterController.Move(new Vector3(0, 0, 1));"},{"type":"paragraph","children":[{"type":"inlineCode","value":"CharacterController.Move","position":{"start":{"line":70,"column":1,"offset":1879},"end":{"line":70,"column":27,"offset":1905}}},{"type":"text","value":" 比起 ","position":{"start":{"line":70,"column":27,"offset":1905},"end":{"line":70,"column":31,"offset":1909}}},{"type":"inlineCode","value":"Rigidbody.AddForce","position":{"start":{"line":70,"column":31,"offset":1909},"end":{"line":70,"column":51,"offset":1929}}},{"type":"text","value":" 更加平滑，且會受碰撞影響，比起 ","position":{"start":{"line":70,"column":51,"offset":1929},"end":{"line":70,"column":68,"offset":1946}}},{"type":"inlineCode","value":"Transform.position","position":{"start":{"line":70,"column":68,"offset":1946},"end":{"line":70,"column":88,"offset":1966}}},{"type":"text","value":" 更加自然。","position":{"start":{"line":70,"column":88,"offset":1966},"end":{"line":70,"column":94,"offset":1972}}}]},{"type":"paragraph","children":[{"type":"text","value":"另外，值得注意的是有些動畫內建位移，若啟用 Root Motion 即使未使用任何移動函數仍然會移動物體，設計角色移動時必須將此一因素考慮進去。","position":{"start":{"line":72,"column":1,"offset":1974},"end":{"line":72,"column":73,"offset":2046}}}]},{"type":"heading","depth":1,"children":[{"type":"text","value":"Execution Order","position":{"start":{"line":74,"column":3,"offset":2050},"end":{"line":74,"column":18,"offset":2065}}}]},{"type":"paragraph","children":[{"type":"text","value":"Unity 新增 script 的初始範本都包含兩個函數： ","position":{"start":{"line":76,"column":1,"offset":2067},"end":{"line":76,"column":31,"offset":2097}}},{"type":"inlineCode","value":"Start()","position":{"start":{"line":76,"column":31,"offset":2097},"end":{"line":76,"column":40,"offset":2106}}},{"type":"text","value":" 與 ","position":{"start":{"line":76,"column":40,"offset":2106},"end":{"line":76,"column":43,"offset":2109}}},{"type":"inlineCode","value":"Update()","position":{"start":{"line":76,"column":43,"offset":2109},"end":{"line":76,"column":53,"offset":2119}}},{"type":"text","value":" 。這兩個函數都是腳本系統的核心之一。","position":{"start":{"line":76,"column":53,"offset":2119},"end":{"line":76,"column":72,"offset":2138}}}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Start()","position":{"start":{"line":78,"column":4,"offset":2143},"end":{"line":78,"column":11,"offset":2150}}}]},{"type":"paragraph","children":[{"type":"text","value":"Start 會在 script 啟動後，Update 的第一個 frame 更新前被呼叫。整個腳本生命中只會被呼叫這一次。","position":{"start":{"line":80,"column":1,"offset":2152},"end":{"line":80,"column":62,"offset":2213}}}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"Update()","position":{"start":{"line":82,"column":4,"offset":2218},"end":{"line":82,"column":12,"offset":2226}}}]},{"type":"paragraph","children":[{"type":"text","value":"Update 會在每一幀 (frame) 都被呼叫一次。玩家指令，角色移動等等都可以在這之中執行循環確認。但每一幀呼叫一次有一個問題，這代表 Update() 的呼叫頻率受客戶端的幀數影響，規格好幀數高呼叫次數就多，規格差呼叫次數就少，這將在玩家之間造成不平衡。","position":{"start":{"line":84,"column":1,"offset":2228},"end":{"line":84,"column":132,"offset":2359}}}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"FixedUpdate()","position":{"start":{"line":86,"column":4,"offset":2364},"end":{"line":86,"column":17,"offset":2377}}}]},{"type":"paragraph","children":[{"type":"text","value":"FixedUpdate 呼叫次數比 Update 高，且不綁定幀數，如果客戶端幀數低， FixedUpdate 可能在一幀之中呼叫數次，相反地若客戶端幀數高， FixedUpdate 也可能一幀呼叫不到一次。所有物理模擬與運算都會在 FixedUpdate 結束後立刻發生。","position":{"start":{"line":88,"column":1,"offset":2379},"end":{"line":88,"column":138,"offset":2516}}}]},{"type":"heading","depth":2,"children":[{"type":"text","value":"LateUpdate()","position":{"start":{"line":90,"column":4,"offset":2521},"end":{"line":90,"column":16,"offset":2533}}}]},{"type":"paragraph","children":[{"type":"text","value":"LateUpdate() 會在 Update() 結束後被呼叫，所以也是一幀一次。LateUpdate() 被呼叫時， Update() 的運算已經全數完成。常見的使用場合是計算攝影機位置，能夠保證在角色完成移動後，攝影機才移動到需要的位置。","position":{"start":{"line":92,"column":1,"offset":2535},"end":{"line":92,"column":122,"offset":2656}}}]},{"type":"heading","depth":1,"children":[{"type":"text","value":"Hitbox and hurtbox","position":{"start":{"line":94,"column":3,"offset":2660},"end":{"line":94,"column":21,"offset":2678}}}]},{"type":"paragraph","children":[{"type":"text","value":"3D 遊戲不可避免的就是 hitbox 與 hurtbox 的計算。這個功能可以使用 ","position":{"start":{"line":96,"column":1,"offset":2680},"end":{"line":96,"column":44,"offset":2723}}},{"type":"inlineCode","value":"Physics.OverlapBox()","position":{"start":{"line":96,"column":44,"offset":2723},"end":{"line":96,"column":66,"offset":2745}}},{"type":"text","value":" 達成。這個函數的功用是指定一個中心點與三維距離所建構的立方體，尋找所有進入這個立方體的其他碰撞體 (Collider)。更甚還可以指定 Layer ，將判斷對象限定在特定 Layer 。","position":{"start":{"line":96,"column":66,"offset":2745},"end":{"line":96,"column":160,"offset":2839}}}]},{"type":"paragraph","children":[{"type":"text","value":"首先給想要賦予 Hitbox 的物體，比如說角色的拳頭，增加一個 Collider ，然後勾選 ","position":{"start":{"line":98,"column":1,"offset":2841},"end":{"line":98,"column":49,"offset":2889}}},{"type":"inlineCode","value":"Is Trigger","position":{"start":{"line":98,"column":49,"offset":2889},"end":{"line":98,"column":61,"offset":2901}}},{"type":"text","value":" 。這個選項可以讓該 Collider 不會與其他 Collider 造成碰撞與物理位移，而只會偵測碰撞體之間的重疊並依此觸發事件。具體實作如下：","position":{"start":{"line":98,"column":61,"offset":2901},"end":{"line":98,"column":134,"offset":2974}}}]},{"type":"code","lang":"csharp","meta":null,"value":"public class AttackController : MonoBehaviour\n{\n\t\tpublic Collider Hitbox;\n\t\tpublic int ATK;\n\t\tprivate List<GameObject> hitEnemies = new List<GameObject>();\n\t\t\t\n\t\tvoid Update()\n\t\t{\n        DetectAttack(Hitbox);\n\t\t}\n\t\t\n\t\tpublic void ClearHitEnemyList()\n\t\t{\n\t\t    hitEnemies.Clear();\n\t\t}\n\n\t\tvoid DetectAttack(Collider hitbox)\n\t\t{\n\t\t    Collider[] hurtboxes = Physics.OverlapBox(\n\t\t        hitbox.bounds.center, // 中心點\n\t\t        hitbox.bounds.extents, // 三維尺寸\n\t\t        hitbox.transform.rotation, // 三維角度\n\t\t        LayerMask.GetMask(\"{INSERT LAYER NAME}\") // 指定對象 layer\n\t\t    );\n\t\t    \n\t\t\t\t// hurtboxed 就是這次攻擊所有被註冊的受攻擊碰撞體\n\t\t    foreach (Collider hurtbox in hurtboxes)\n\t\t    {\n\t\t        GameObject enemy = hurtbox.gameObject;\n\t\t        if (!hitEnemies.Contains(enemy))\n\t\t        {\n\t\t            hitEnemies.Add(enemy);\n\t\t            enemy.doAnythingYouWant(...);\n\t\t        }\n\t\t    }\n\t\t}\n}"},{"type":"paragraph","children":[{"type":"text","value":"我在這邊已經加入了對同一目標的重複判斷，因為 hitbox 與 hurtbox 在同一次攻擊內也可能重合複數次，使用一個 List 記錄目標並比對每次擊中的目標是否已在本次攻擊的目標列表裡。開始攻擊時呼叫 ","position":{"start":{"line":140,"column":1,"offset":3874},"end":{"line":140,"column":104,"offset":3977}}},{"type":"inlineCode","value":"ClearHitEnemyList","position":{"start":{"line":140,"column":104,"offset":3977},"end":{"line":140,"column":123,"offset":3996}}},{"type":"text","value":" 清空列表即可。","position":{"start":{"line":140,"column":123,"offset":3996},"end":{"line":140,"column":131,"offset":4004}}}]},{"type":"paragraph","children":[{"type":"text","value":"最後的 ","position":{"start":{"line":142,"column":1,"offset":4006},"end":{"line":142,"column":5,"offset":4010}}},{"type":"inlineCode","value":"enemy","position":{"start":{"line":142,"column":5,"offset":4010},"end":{"line":142,"column":12,"offset":4017}}},{"type":"text","value":" 是受到攻擊的 collider 的父物件本身，如果該物件在受到攻擊時呼叫的腳本在該物件身上，等於要從攻擊角色的 hitbox 腳本呼叫另一個物件的腳本，可以使用 ","position":{"start":{"line":142,"column":12,"offset":4017},"end":{"line":142,"column":94,"offset":4099}}},{"type":"inlineCode","value":".SendMessageUpwards(\"{INSERT FUNC NAME}\", {INSERT FUNC PARAM})","position":{"start":{"line":142,"column":94,"offset":4099},"end":{"line":142,"column":158,"offset":4163}}},{"type":"text","value":" 。這個函數可以向上呼叫該腳本父物件的其他函數。","position":{"start":{"line":142,"column":158,"offset":4163},"end":{"line":142,"column":182,"offset":4187}}}]}],"postSummary":{"id":"unity-dev-memo-1","title":"Unity Dev Memo (1)","category":"Game Development","language":["zh-TW"],"tags":["Unity3D"],"publishDate":"2020-03-08","pathname":"unity-dev-memo-1","zhTwLink":null,"filename":"Unity Dev Memo (1) (blog)"}},"__N_SSG":true}
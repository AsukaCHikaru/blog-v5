<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>Unity Dev Memo (1) | Asuka Wang</title><meta name="description" content="關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。"><meta property="og:title" content="Unity Dev Memo (1) | Asuka Wang"><meta property="twitter:title" content="Unity Dev Memo (1) | Asuka Wang"><meta name="next-head-count" content="6"><link rel="preload" href="/_next/static/css/8db452c70a1fa85d.css" as="style"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Gentium_Plus-400-62b8f514fb.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Serif_JP_CJK-400-0edade8171.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Serif_JP-400-10e25bcd0f.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Gentium_Plus_Book-700-47a76121c3.woff2"><link rel="stylesheet" href="/subfont/fonts-cbb3112893.css"><link rel="stylesheet" href="/_next/static/css/8db452c70a1fa85d.css" data-n-g=""><link rel="preload" href="/_next/static/css/7803970f8f8ed940.css" as="style"><link rel="stylesheet" href="/_next/static/css/7803970f8f8ed940.css" data-n-p=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-f2ca60db2beb93ed.js" defer=""></script><script src="/_next/static/chunks/pages/_app-be51c38591acb686.js" defer=""></script><script src="/_next/static/chunks/542-7be5b5539309fe0b.js" defer=""></script><script src="/_next/static/chunks/210-a21040367ba19255.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bpathname%5D-3bf5f7f615781b02.js" defer=""></script><script src="/_next/static/YmR_5W6-BJxdLSihqwoLx/_buildManifest.js" defer=""></script><script src="/_next/static/YmR_5W6-BJxdLSihqwoLx/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><div class="text-color Layout_container__S4aNf" data-is-menu-open="false"><div class="SiteHeader_container__8tKwA" data-is-menu-open="false"><div class="SiteHeader_nav-container__oEq2d"><div class="SiteHeader_section-container__tAKnZ"><a class="SiteHeader_section-link__9DmFE interactive-color text-color" href="/blog/">blog</a><a class="SiteHeader_section-link__9DmFE interactive-color " href="/about/">about</a><a target="_blank" class="SiteHeader_section-link__9DmFE interactive-color" href="/blog/feed.xml">rss</a></div><button class="SiteHeader_menu-button__eK9ND">menu</button><a class="SiteHeader_publication-folio___ZFZS text-color" href="/">ASUKA WANG</a></div><div class="SiteHeader_divider__cq_R_ border-color-100"></div><div class="SiteHeader_menu-wrapper__2evr7"></div></div><div class="Layout_full-content__MQIxS"><div class="PostDetailPageHeader_container__fcMw9"><div class="Layout_main-content__mr9_2"><h1 class="PostDetailPageHeader_title__YwZEK">Unity Dev Memo (1)</h1><h2 class="PostDetailPageHeader_description__HSXhn">關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。</h2><div class="PostDetailPageHeader_publish-date__pMF22">March 8, 2020</div></div></div></div><div class="Layout_main-content__mr9_2"><div class="PostBodyBlock_wrapper__wRxJc">在數年的醞釀以及一時的心血來潮以後，我開始第一次真正投入時間學習 Unity 。至今一週，最大的感想是過往兩年自學程式的經驗惠我良多，但並不是因為程式的概念等，而是在尋找資源，搜尋關鍵字，看文件的速度上，比起兩三年前另一次摸 Unity 的時候有效率太多了。以下是這一週學到的我覺得值得筆記的部分。</div><div class="PostBodyBlock_wrapper__wRxJc"><h2 class="PostBodyBlock_h2__z8Iri" id="object-movement">Object movement</h2></div><div class="PostBodyBlock_wrapper__wRxJc">在 Unity ，要讓一個物體移動有三種方式：</div><div class="PostBodyBlock_wrapper__wRxJc"><ul class="PostBodyBlock_ul__QtcuL"><li><code class="PostBodyBlock_inline-code__TAzYM">Transform.position</code></li><li><code class="PostBodyBlock_inline-code__TAzYM">Rigidbody.AddForce()</code></li><li><code class="PostBodyBlock_inline-code__TAzYM">CharacterController.Move()</code></li></ul></div><div class="PostBodyBlock_wrapper__wRxJc"><h3 class="PostBodyBlock_h3__BUDla" id="transform-position">Transform.position</h3></div><div class="PostBodyBlock_wrapper__wRxJc"><code class="PostBodyBlock_inline-code__TAzYM">Transform</code> 是每個 gameObject 都有的屬性，掌管了物體的位置 (position)，角度 (rotation) 與大小 (scale) 。這三個屬性都具有 x, y, z 三個子屬性，對 position 你可以使用三維向量 (Vector3) ，對角度可以使用尤拉角 (Eular Angle) 來調整。</div><div class="PostBodyBlock_wrapper__wRxJc">使用 <code class="PostBodyBlock_inline-code__TAzYM">Transform.position</code> 調整物體位置的語法像是這樣：</div><div class="PostBodyBlock_wrapper__wRxJc"><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">Transform.position = new Vector3(0, 0, 1);</code></pre></div><div class="PostBodyBlock_wrapper__wRxJc">在這裡，Vector3 裡面的數字都是整個遊戲地圖裡的絕對值，所以如果想基於物體位置進行移動，必須把物體當前位置也輸入進去。</div><div class="PostBodyBlock_wrapper__wRxJc"><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">Vector3 objectPos = Transform.position;
Transform.position = new Vector3(objetPos.x, objectPos.y, objectPos.z + 1);</code></pre></div><div class="PostBodyBlock_wrapper__wRxJc">這樣就能讓物體朝向 Z 方向移動 1 單位。</div><div class="PostBodyBlock_wrapper__wRxJc">使用 <code class="PostBodyBlock_inline-code__TAzYM">Transform.position</code> 是強制調整物體位置，有點像是瞬間移動。適合的場合有攝影機等。</div><div class="PostBodyBlock_wrapper__wRxJc"><h3 class="PostBodyBlock_h3__BUDla" id="rigidbody-addforce">Rigidbody.Addforce</h3></div><div class="PostBodyBlock_wrapper__wRxJc">來看看官方說明手冊的對 Rigidbody 的第一句說明：</div><div class="PostBodyBlock_wrapper__wRxJc"><blockquote class="QuoteBlock_quoteblock__qr7mG text-color-second"><p>Control of an object's position through physics simulation.</p></blockquote></div><div class="PostBodyBlock_wrapper__wRxJc">Rigidbody 是從物理面上控制物體。 <code class="PostBodyBlock_inline-code__TAzYM">AddForce</code> 就是基於一個 Vector3 的角度給予外力。</div><div class="PostBodyBlock_wrapper__wRxJc"><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">Rigidbody.AddForce(new Vector3(0, 0, 10));</code></pre></div><div class="PostBodyBlock_wrapper__wRxJc">這樣就會對該物體施加一股從 Z 方向來的大小為 10 的外力。</div><div class="PostBodyBlock_wrapper__wRxJc">由於 Rigidbody 是模擬物理，所以外力大小，物體質量等等都會影響物體最終位移距離。如果外力夠大，物體就會跟落葉一樣被吹飛。適合的場合有破壞場景物件等等。</div><div class="PostBodyBlock_wrapper__wRxJc"><h3 class="PostBodyBlock_h3__BUDla" id="charactercontroller-move">CharacterController.Move</h3></div><div class="PostBodyBlock_wrapper__wRxJc">一樣來看看官方手冊的說明：</div><div class="PostBodyBlock_wrapper__wRxJc"><blockquote class="QuoteBlock_quoteblock__qr7mG text-color-second"><p>A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody. A CharacterController is not affected by forces and will only move when you call the Move function. It will then carry out the movement but be constrained by collisions.</p></blockquote></div><div class="PostBodyBlock_wrapper__wRxJc">CharacterControll 是專為移動遊戲角色設計的，而不用使用外力或是瞬間移動的方式，能夠直接操控角色的移動。引數一樣是使用 Vector3 調整三個維度的移動幅度。</div><div class="PostBodyBlock_wrapper__wRxJc"><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">CharacterController.Move(new Vector3(0, 0, 1));</code></pre></div><div class="PostBodyBlock_wrapper__wRxJc"><code class="PostBodyBlock_inline-code__TAzYM">CharacterController.Move</code> 比起 <code class="PostBodyBlock_inline-code__TAzYM">Rigidbody.AddForce</code> 更加平滑，且會受碰撞影響，比起 <code class="PostBodyBlock_inline-code__TAzYM">Transform.position</code> 更加自然。</div><div class="PostBodyBlock_wrapper__wRxJc">另外，值得注意的是有些動畫內建位移，若啟用 Root Motion 即使未使用任何移動函數仍然會移動物體，設計角色移動時必須將此一因素考慮進去。</div><div class="PostBodyBlock_wrapper__wRxJc"><h2 class="PostBodyBlock_h2__z8Iri" id="execution-order">Execution Order</h2></div><div class="PostBodyBlock_wrapper__wRxJc">Unity 新增 script 的初始範本都包含兩個函數： <code class="PostBodyBlock_inline-code__TAzYM">Start()</code> 與 <code class="PostBodyBlock_inline-code__TAzYM">Update()</code> 。這兩個函數都是腳本系統的核心之一。</div><div class="PostBodyBlock_wrapper__wRxJc"><h3 class="PostBodyBlock_h3__BUDla" id="start--">Start()</h3></div><div class="PostBodyBlock_wrapper__wRxJc">Start 會在 script 啟動後，Update 的第一個 frame 更新前被呼叫。整個腳本生命中只會被呼叫這一次。</div><div class="PostBodyBlock_wrapper__wRxJc"><h3 class="PostBodyBlock_h3__BUDla" id="update--">Update()</h3></div><div class="PostBodyBlock_wrapper__wRxJc">Update 會在每一幀 (frame) 都被呼叫一次。玩家指令，角色移動等等都可以在這之中執行循環確認。但每一幀呼叫一次有一個問題，這代表 Update() 的呼叫頻率受客戶端的幀數影響，規格好幀數高呼叫次數就多，規格差呼叫次數就少，這將在玩家之間造成不平衡。</div><div class="PostBodyBlock_wrapper__wRxJc"><h3 class="PostBodyBlock_h3__BUDla" id="fixedupdate--">FixedUpdate()</h3></div><div class="PostBodyBlock_wrapper__wRxJc">FixedUpdate 呼叫次數比 Update 高，且不綁定幀數，如果客戶端幀數低， FixedUpdate 可能在一幀之中呼叫數次，相反地若客戶端幀數高， FixedUpdate 也可能一幀呼叫不到一次。所有物理模擬與運算都會在 FixedUpdate 結束後立刻發生。</div><div class="PostBodyBlock_wrapper__wRxJc"><h3 class="PostBodyBlock_h3__BUDla" id="lateupdate--">LateUpdate()</h3></div><div class="PostBodyBlock_wrapper__wRxJc">LateUpdate() 會在 Update() 結束後被呼叫，所以也是一幀一次。LateUpdate() 被呼叫時， Update() 的運算已經全數完成。常見的使用場合是計算攝影機位置，能夠保證在角色完成移動後，攝影機才移動到需要的位置。</div><div class="PostBodyBlock_wrapper__wRxJc"><h2 class="PostBodyBlock_h2__z8Iri" id="hitbox-and-hurtbox">Hitbox and hurtbox</h2></div><div class="PostBodyBlock_wrapper__wRxJc">3D 遊戲不可避免的就是 hitbox 與 hurtbox 的計算。這個功能可以使用 <code class="PostBodyBlock_inline-code__TAzYM">Physics.OverlapBox()</code> 達成。這個函數的功用是指定一個中心點與三維距離所建構的立方體，尋找所有進入這個立方體的其他碰撞體 (Collider)。更甚還可以指定 Layer ，將判斷對象限定在特定 Layer 。</div><div class="PostBodyBlock_wrapper__wRxJc">首先給想要賦予 Hitbox 的物體，比如說角色的拳頭，增加一個 Collider ，然後勾選 <code class="PostBodyBlock_inline-code__TAzYM">Is Trigger</code> 。這個選項可以讓該 Collider 不會與其他 Collider 造成碰撞與物理位移，而只會偵測碰撞體之間的重疊並依此觸發事件。具體實作如下：</div><div class="PostBodyBlock_wrapper__wRxJc"><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">public class AttackController : MonoBehaviour
{
		public Collider Hitbox;
		public int ATK;
		private List&lt;GameObject&gt; hitEnemies = new List&lt;GameObject&gt;();

		void Update()
		{
        DetectAttack(Hitbox);
		}

		public void ClearHitEnemyList()
		{
		    hitEnemies.Clear();
		}

		void DetectAttack(Collider hitbox)
		{
		    Collider[] hurtboxes = Physics.OverlapBox(
		        hitbox.bounds.center, // 中心點
		        hitbox.bounds.extents, // 三維尺寸
		        hitbox.transform.rotation, // 三維角度
		        LayerMask.GetMask("{INSERT LAYER NAME}") // 指定對象 layer
		    );

				// hurtboxed 就是這次攻擊所有被註冊的受攻擊碰撞體
		    foreach (Collider hurtbox in hurtboxes)
		    {
		        GameObject enemy = hurtbox.gameObject;
		        if (!hitEnemies.Contains(enemy))
		        {
		            hitEnemies.Add(enemy);
		            enemy.doAnythingYouWant(...);
		        }
		    }
		}
}</code></pre></div><div class="PostBodyBlock_wrapper__wRxJc">我在這邊已經加入了對同一目標的重複判斷，因為 hitbox 與 hurtbox 在同一次攻擊內也可能重合複數次，使用一個 List 記錄目標並比對每次擊中的目標是否已在本次攻擊的目標列表裡。開始攻擊時呼叫 <code class="PostBodyBlock_inline-code__TAzYM">ClearHitEnemyList</code> 清空列表即可。</div><div class="PostBodyBlock_wrapper__wRxJc">最後的 <code class="PostBodyBlock_inline-code__TAzYM">enemy</code> 是受到攻擊的 collider 的父物件本身，如果該物件在受到攻擊時呼叫的腳本在該物件身上，等於要從攻擊角色的 hitbox 腳本呼叫另一個物件的腳本，可以使用 <code class="PostBodyBlock_inline-code__TAzYM">.SendMessageUpwards("{INSERT FUNC NAME}", {INSERT FUNC PARAM})</code> 。這個函數可以向上呼叫該腳本父物件的其他函數。</div><div class="PostDetailPage_additional-list-container__b_oHL"><div class="AdditionalPostList_container__ucjfo"><div class="AdditionalPostList_category-link__EDTWa">More from<a href="/blog/archive/?category=note">note</a></div><div class="AdditionalPostList_card-list__jz3F_"><a class="AdditionalPostList_card__doJcw" href="/blog/thoughts-on-building-a-game-with-xstate/"><div><div class="AdditionalPostList_card-title__FDhSX">Thoughts on Building a Game with XState</div><div class="AdditionalPostList_card-description__Enc8v">After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 4, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/godot-essentials/"><div><div class="AdditionalPostList_card-title__FDhSX">Godot Essentials</div><div class="AdditionalPostList_card-description__Enc8v">The biggest lessons I learned in my first Godot project.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">April 21, 2024</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/unity-dev-memo-2/"><div><div class="AdditionalPostList_card-title__FDhSX">Unity Dev Memo (2)</div><div class="AdditionalPostList_card-description__Enc8v">關於 Unity3D 內 raycast 的研究筆記。</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">October 4, 2020</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/a-rather-easy-way-to-implement-quicksort-in-js/"><div><div class="AdditionalPostList_card-title__FDhSX">A Rather Easy Way to Implement Quicksort in JavaScript</div><div class="AdditionalPostList_card-description__Enc8v">My attempt to implement quicksort.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">May 23, 2019</div></a></div></div><div class="AdditionalPostList_container__ucjfo"><a class="AdditionalPostList_archive-link__7Q6ys" href="/blog/archive/">Archive</a><div class="AdditionalPostList_card-list__jz3F_"><a class="AdditionalPostList_card__doJcw" href="/blog/blogging-and-digital-gardening/"><div><div class="AdditionalPostList_card-title__FDhSX">Blogging and Digital Gardening in the Social Platform and Generative AI Era</div><div class="AdditionalPostList_card-description__Enc8v">I talk to myself about why bother writing at somewhere nobody comes.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">February 11, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/a-redemption-three-years-later/"><div><div class="AdditionalPostList_card-title__FDhSX">A Redemption Three Years Later</div><div class="AdditionalPostList_card-description__Enc8v">CD PROJEKT RED made a promise about Night City, which they broke. Three years later they had another attempt, and to me, it was their redemption.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 13, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/s14-recap/"><div><div class="AdditionalPostList_card-title__FDhSX">S14 Recap</div><div class="AdditionalPostList_card-description__Enc8v">I did not play a lot of league during 2024, but I had a few unforgettable moments nonetheless.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 7, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/thoughts-on-building-a-game-with-xstate/"><div><div class="AdditionalPostList_card-title__FDhSX">Thoughts on Building a Game with XState</div><div class="AdditionalPostList_card-description__Enc8v">After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 4, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/under-the-hood-diablo-ii-item-generation/"><div><div class="AdditionalPostList_card-title__FDhSX">Under the Hood: Diablo II Item Generation</div><div class="AdditionalPostList_card-description__Enc8v">A system design research turned into a reconciliation with a game I didn't know I was so in love with, so I wrote a research note to express my appreciation.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">November 8, 2024</div></a></div></div></div></div><div class="Layout_right-panel__zSn4t"><div class="TableOfContentColumn_container__0tmUV"><ul class="TableOfContentColumn_ul__7wuVs interactive-list-color"><li class="TableOfContentColumn_li__FUe4z"><button role="link" class="TableOfContentColumn_link__5qS3c">Object movement</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">Transform.position</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">Rigidbody.Addforce</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">CharacterController.Move</button></li><li class="TableOfContentColumn_li__FUe4z"><button role="link" class="TableOfContentColumn_link__5qS3c">Execution Order</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">Start()</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">Update()</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">FixedUpdate()</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">LateUpdate()</button></li><li class="TableOfContentColumn_li__FUe4z"><button role="link" class="TableOfContentColumn_link__5qS3c">Hitbox and hurtbox</button></li></ul></div></div><div class="SiteFooter_container__0v6cR border-color"><a href="https://asukawang.com" rel="noopener noreferrer" target="_blank" class="SiteFooter_link__RuMSe interactive-color">asukawang.com 2018-</a></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postContent":[{"type":"paragraph","children":[{"type":"plain","text":"在數年的醞釀以及一時的心血來潮以後，我開始第一次真正投入時間學習 Unity 。至今一週，最大的感想是過往兩年自學程式的經驗惠我良多，但並不是因為程式的概念等，而是在尋找資源，搜尋關鍵字，看文件的速度上，比起兩三年前另一次摸 Unity 的時候有效率太多了。以下是這一週學到的我覺得值得筆記的部分。"}]},{"type":"heading","children":[{"type":"plain","text":"Object movement"}],"depth":1},{"type":"paragraph","children":[{"type":"plain","text":"在 Unity ，要讓一個物體移動有三種方式："}]},{"type":"list","ordered":false,"children":[{"type":"listItem","children":[{"type":"inlineCode","text":"Transform.position"}]},{"type":"listItem","children":[{"type":"inlineCode","text":"Rigidbody.AddForce()"}]},{"type":"listItem","children":[{"type":"inlineCode","text":"CharacterController.Move()"}]}]},{"type":"heading","children":[{"type":"plain","text":"Transform.position"}],"depth":2},{"type":"paragraph","children":[{"type":"inlineCode","text":"Transform"},{"type":"plain","text":" 是每個 gameObject 都有的屬性，掌管了物體的位置 (position)，角度 (rotation) 與大小 (scale) 。這三個屬性都具有 x, y, z 三個子屬性，對 position 你可以使用三維向量 (Vector3) ，對角度可以使用尤拉角 (Eular Angle) 來調整。"}]},{"type":"paragraph","children":[{"type":"plain","text":"使用 "},{"type":"inlineCode","text":"Transform.position"},{"type":"plain","text":" 調整物體位置的語法像是這樣："}]},{"type":"code","lang":"csharp","text":"Transform.position = new Vector3(0, 0, 1);"},{"type":"paragraph","children":[{"type":"plain","text":"在這裡，Vector3 裡面的數字都是整個遊戲地圖裡的絕對值，所以如果想基於物體位置進行移動，必須把物體當前位置也輸入進去。"}]},{"type":"code","lang":"csharp","text":"Vector3 objectPos = Transform.position;\nTransform.position = new Vector3(objetPos.x, objectPos.y, objectPos.z + 1);"},{"type":"paragraph","children":[{"type":"plain","text":"這樣就能讓物體朝向 Z 方向移動 1 單位。"}]},{"type":"paragraph","children":[{"type":"plain","text":"使用 "},{"type":"inlineCode","text":"Transform.position"},{"type":"plain","text":" 是強制調整物體位置，有點像是瞬間移動。適合的場合有攝影機等。"}]},{"type":"heading","children":[{"type":"plain","text":"Rigidbody.Addforce"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"來看看官方說明手冊的對 Rigidbody 的第一句說明："}]},{"type":"quote","children":[{"type":"plain","text":"Control of an object's position through physics simulation."}]},{"type":"paragraph","children":[{"type":"plain","text":"Rigidbody 是從物理面上控制物體。 "},{"type":"inlineCode","text":"AddForce"},{"type":"plain","text":" 就是基於一個 Vector3 的角度給予外力。"}]},{"type":"code","lang":"csharp","text":"Rigidbody.AddForce(new Vector3(0, 0, 10));"},{"type":"paragraph","children":[{"type":"plain","text":"這樣就會對該物體施加一股從 Z 方向來的大小為 10 的外力。"}]},{"type":"paragraph","children":[{"type":"plain","text":"由於 Rigidbody 是模擬物理，所以外力大小，物體質量等等都會影響物體最終位移距離。如果外力夠大，物體就會跟落葉一樣被吹飛。適合的場合有破壞場景物件等等。"}]},{"type":"heading","children":[{"type":"plain","text":"CharacterController.Move"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"一樣來看看官方手冊的說明："}]},{"type":"quote","children":[{"type":"plain","text":"A CharacterController allows you to easily do movement constrained by collisions without having to deal with a rigidbody. A CharacterController is not affected by forces and will only move when you call the Move function. It will then carry out the movement but be constrained by collisions."}]},{"type":"paragraph","children":[{"type":"plain","text":"CharacterControll 是專為移動遊戲角色設計的，而不用使用外力或是瞬間移動的方式，能夠直接操控角色的移動。引數一樣是使用 Vector3 調整三個維度的移動幅度。"}]},{"type":"code","lang":"csharp","text":"CharacterController.Move(new Vector3(0, 0, 1));"},{"type":"paragraph","children":[{"type":"inlineCode","text":"CharacterController.Move"},{"type":"plain","text":" 比起 "},{"type":"inlineCode","text":"Rigidbody.AddForce"},{"type":"plain","text":" 更加平滑，且會受碰撞影響，比起 "},{"type":"inlineCode","text":"Transform.position"},{"type":"plain","text":" 更加自然。"}]},{"type":"paragraph","children":[{"type":"plain","text":"另外，值得注意的是有些動畫內建位移，若啟用 Root Motion 即使未使用任何移動函數仍然會移動物體，設計角色移動時必須將此一因素考慮進去。"}]},{"type":"heading","children":[{"type":"plain","text":"Execution Order"}],"depth":1},{"type":"paragraph","children":[{"type":"plain","text":"Unity 新增 script 的初始範本都包含兩個函數： "},{"type":"inlineCode","text":"Start()"},{"type":"plain","text":" 與 "},{"type":"inlineCode","text":"Update()"},{"type":"plain","text":" 。這兩個函數都是腳本系統的核心之一。"}]},{"type":"heading","children":[{"type":"plain","text":"Start()"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"Start 會在 script 啟動後，Update 的第一個 frame 更新前被呼叫。整個腳本生命中只會被呼叫這一次。"}]},{"type":"heading","children":[{"type":"plain","text":"Update()"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"Update 會在每一幀 (frame) 都被呼叫一次。玩家指令，角色移動等等都可以在這之中執行循環確認。但每一幀呼叫一次有一個問題，這代表 Update() 的呼叫頻率受客戶端的幀數影響，規格好幀數高呼叫次數就多，規格差呼叫次數就少，這將在玩家之間造成不平衡。"}]},{"type":"heading","children":[{"type":"plain","text":"FixedUpdate()"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"FixedUpdate 呼叫次數比 Update 高，且不綁定幀數，如果客戶端幀數低， FixedUpdate 可能在一幀之中呼叫數次，相反地若客戶端幀數高， FixedUpdate 也可能一幀呼叫不到一次。所有物理模擬與運算都會在 FixedUpdate 結束後立刻發生。"}]},{"type":"heading","children":[{"type":"plain","text":"LateUpdate()"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"LateUpdate() 會在 Update() 結束後被呼叫，所以也是一幀一次。LateUpdate() 被呼叫時， Update() 的運算已經全數完成。常見的使用場合是計算攝影機位置，能夠保證在角色完成移動後，攝影機才移動到需要的位置。"}]},{"type":"heading","children":[{"type":"plain","text":"Hitbox and hurtbox"}],"depth":1},{"type":"paragraph","children":[{"type":"plain","text":"3D 遊戲不可避免的就是 hitbox 與 hurtbox 的計算。這個功能可以使用 "},{"type":"inlineCode","text":"Physics.OverlapBox()"},{"type":"plain","text":" 達成。這個函數的功用是指定一個中心點與三維距離所建構的立方體，尋找所有進入這個立方體的其他碰撞體 (Collider)。更甚還可以指定 Layer ，將判斷對象限定在特定 Layer 。"}]},{"type":"paragraph","children":[{"type":"plain","text":"首先給想要賦予 Hitbox 的物體，比如說角色的拳頭，增加一個 Collider ，然後勾選 "},{"type":"inlineCode","text":"Is Trigger"},{"type":"plain","text":" 。這個選項可以讓該 Collider 不會與其他 Collider 造成碰撞與物理位移，而只會偵測碰撞體之間的重疊並依此觸發事件。具體實作如下："}]},{"type":"code","lang":"csharp","text":"public class AttackController : MonoBehaviour\n{\n\t\tpublic Collider Hitbox;\n\t\tpublic int ATK;\n\t\tprivate List\u003cGameObject\u003e hitEnemies = new List\u003cGameObject\u003e();\n\n\t\tvoid Update()\n\t\t{\n        DetectAttack(Hitbox);\n\t\t}\n\n\t\tpublic void ClearHitEnemyList()\n\t\t{\n\t\t    hitEnemies.Clear();\n\t\t}\n\n\t\tvoid DetectAttack(Collider hitbox)\n\t\t{\n\t\t    Collider[] hurtboxes = Physics.OverlapBox(\n\t\t        hitbox.bounds.center, // 中心點\n\t\t        hitbox.bounds.extents, // 三維尺寸\n\t\t        hitbox.transform.rotation, // 三維角度\n\t\t        LayerMask.GetMask(\"{INSERT LAYER NAME}\") // 指定對象 layer\n\t\t    );\n\n\t\t\t\t// hurtboxed 就是這次攻擊所有被註冊的受攻擊碰撞體\n\t\t    foreach (Collider hurtbox in hurtboxes)\n\t\t    {\n\t\t        GameObject enemy = hurtbox.gameObject;\n\t\t        if (!hitEnemies.Contains(enemy))\n\t\t        {\n\t\t            hitEnemies.Add(enemy);\n\t\t            enemy.doAnythingYouWant(...);\n\t\t        }\n\t\t    }\n\t\t}\n}"},{"type":"paragraph","children":[{"type":"plain","text":"我在這邊已經加入了對同一目標的重複判斷，因為 hitbox 與 hurtbox 在同一次攻擊內也可能重合複數次，使用一個 List 記錄目標並比對每次擊中的目標是否已在本次攻擊的目標列表裡。開始攻擊時呼叫 "},{"type":"inlineCode","text":"ClearHitEnemyList"},{"type":"plain","text":" 清空列表即可。"}]},{"type":"paragraph","children":[{"type":"plain","text":"最後的 "},{"type":"inlineCode","text":"enemy"},{"type":"plain","text":" 是受到攻擊的 collider 的父物件本身，如果該物件在受到攻擊時呼叫的腳本在該物件身上，等於要從攻擊角色的 hitbox 腳本呼叫另一個物件的腳本，可以使用 "},{"type":"inlineCode","text":".SendMessageUpwards(\"{INSERT FUNC NAME}\", {INSERT FUNC PARAM})"},{"type":"plain","text":" 。這個函數可以向上呼叫該腳本父物件的其他函數。"}]}],"postMetadata":{"id":"unity-dev-memo-1","title":"Unity Dev Memo (1)","description":"關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。","category":"note","topic":"game development","tags":[],"publishDate":"2020-03-08","pathname":"unity-dev-memo-1"},"last5posts":[{"id":"blogging-and-digital-gardening","title":"Blogging and Digital Gardening in the Social Platform and Generative AI Era","description":"I talk to myself about why bother writing at somewhere nobody comes.","category":"essay","topic":"life","tags":[],"publishDate":"2025-02-11","pathname":"blogging-and-digital-gardening"},{"id":"a-redemption-three-years-later","title":"A Redemption Three Years Later","description":"CD PROJEKT RED made a promise about Night City, which they broke. Three years later they had another attempt, and to me, it was their redemption.","category":"review","topic":"gaming","tags":[],"publishDate":"2025-01-13","pathname":"a-redemption-three-years-later"},{"id":"s14-recap","title":"S14 Recap","description":"I did not play a lot of league during 2024, but I had a few unforgettable moments nonetheless.","category":"retrospective","topic":"gaming","tags":[],"publishDate":"2025-01-07","pathname":"s14-recap"},{"id":"thoughts-on-building-a-game-with-xstate","title":"Thoughts on Building a Game with XState","description":"After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.","category":"note","topic":"game development","tags":[],"publishDate":"2025-01-04","pathname":"thoughts-on-building-a-game-with-xstate"},{"id":"under-the-hood-diablo-ii-item-generation","title":"Under the Hood: Diablo II Item Generation","description":"A system design research turned into a reconciliation with a game I didn't know I was so in love with, so I wrote a research note to express my appreciation.","category":"research","topic":"game development","tags":[],"publishDate":"2024-11-08","pathname":"under-the-hood-diablo-ii-item-generation"}],"categoryPosts":[{"id":"thoughts-on-building-a-game-with-xstate","title":"Thoughts on Building a Game with XState","description":"After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.","category":"note","topic":"game development","tags":[],"publishDate":"2025-01-04","pathname":"thoughts-on-building-a-game-with-xstate"},{"id":"godot-essentials","title":"Godot Essentials","description":"The biggest lessons I learned in my first Godot project.","category":"note","topic":"game development","tags":[],"publishDate":"2024-04-21","pathname":"godot-essentials"},{"id":"unity-dev-memo-2","title":"Unity Dev Memo (2)","description":"關於 Unity3D 內 raycast 的研究筆記。","category":"note","topic":"game development","tags":[],"publishDate":"2020-10-04","pathname":"unity-dev-memo-2"},{"id":"a-rather-easy-way-to-implement-quicksort-in-js","title":"A Rather Easy Way to Implement Quicksort in JavaScript","description":"My attempt to implement quicksort.","category":"note","topic":"programming","tags":[],"publishDate":"2019-05-23","pathname":"a-rather-easy-way-to-implement-quicksort-in-js"}],"categories":[{"name":"essay","count":12},{"name":"review","count":15},{"name":"retrospective","count":15},{"name":"note","count":9},{"name":"research","count":3}]},"__N_SSG":true},"page":"/blog/[pathname]","query":{"pathname":"unity-dev-memo-1"},"buildId":"YmR_5W6-BJxdLSihqwoLx","isFallback":false,"gsp":true,"scriptLoader":[]}</script><script>(function(){var el=document.createElement('link');el.href='/subfont/fallback-1f9f028477.css';el.rel='stylesheet';document.body.appendChild(el)}())</script><noscript><link rel="stylesheet" href="/subfont/fallback-1f9f028477.css"></noscript></body></html>
<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>Unity Dev Memo (2) | Asuka Wang</title><meta name="description" content="關於 Unity3D 內 raycast 的研究筆記。"><meta property="og:title" content="Unity Dev Memo (2) | Asuka Wang"><meta property="twitter:title" content="Unity Dev Memo (2) | Asuka Wang"><meta name="next-head-count" content="6"><link rel="preload" href="/_next/static/css/8db452c70a1fa85d.css" as="style"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Gentium_Plus-400-62b8f514fb.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Serif_JP_CJK-400-0edade8171.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Serif_JP-400-10e25bcd0f.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Gentium_Plus_Book-700-47a76121c3.woff2"><link rel="stylesheet" href="/subfont/fonts-cbb3112893.css"><link rel="stylesheet" href="/_next/static/css/8db452c70a1fa85d.css" data-n-g=""><link rel="preload" href="/_next/static/css/49cf73cbd6411833.css" as="style"><link rel="stylesheet" href="/_next/static/css/49cf73cbd6411833.css" data-n-p=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-f2ca60db2beb93ed.js" defer=""></script><script src="/_next/static/chunks/pages/_app-be51c38591acb686.js" defer=""></script><script src="/_next/static/chunks/542-7be5b5539309fe0b.js" defer=""></script><script src="/_next/static/chunks/210-f3c05fdc9f56963b.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bpathname%5D-5fe171a485dfba8b.js" defer=""></script><script src="/_next/static/4Ynmg8plvSU9VjJd-mk9l/_buildManifest.js" defer=""></script><script src="/_next/static/4Ynmg8plvSU9VjJd-mk9l/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><div class="text-color Layout_container__S4aNf" data-is-menu-open="false"><div class="SiteHeader_container__8tKwA" data-is-menu-open="false"><div class="SiteHeader_nav-container__oEq2d"><div class="SiteHeader_section-container__tAKnZ"><a class="SiteHeader_section-link__9DmFE interactive-color text-color" href="/blog/">blog</a><a class="SiteHeader_section-link__9DmFE interactive-color " href="/about/">about</a><a target="_blank" class="SiteHeader_section-link__9DmFE interactive-color" href="/blog/feed.xml">rss</a></div><button class="SiteHeader_menu-button__eK9ND">menu</button><a class="SiteHeader_publication-folio___ZFZS text-color" href="/">ASUKA WANG</a></div><div class="SiteHeader_divider__cq_R_ border-color-100"></div><div class="SiteHeader_menu-wrapper__2evr7"></div></div><div class="Layout_full-content__MQIxS"><div class="PostDetailPageHeader_container__fcMw9"><div class="Layout_main-content__mr9_2"><h1 class="PostDetailPageHeader_title__YwZEK">Unity Dev Memo (2)</h1><h2 class="PostDetailPageHeader_description__HSXhn">關於 Unity3D 內 raycast 的研究筆記。</h2><div class="PostDetailPageHeader_publish-date__pMF22">October 4, 2020</div></div></div></div><div class="Layout_main-content__mr9_2"><article class="PostDetailPage_article__K8T4B"><h3 class="PostBodyBlock_h3__BUDla" id="raycast">Raycast</h3><p>在使用滑鼠的 3D 遊戲中，幾乎與任何物件互動都需要使用滑鼠，判斷玩家游標的位置自然是非常重要且基礎的技術。然而相對 3D 世界的三維座標，存在於螢幕上的游標只有二維座標的 X 軸與 Y 軸兩個數據代表位置，這使得在遊戲世界中精準定位游標位置變得困難。</p><p>不過，大多數想要在遊戲中取得游標位置時，都是為了與存在該位置的物件互動。這個物件就能成為定位游標的輔助工具，只要計算從玩家視角中的游標，是否真正與遊戲世界中的該物件重合即可。</p><p>具體來說，這個判斷方式是從攝影機朝向滑鼠的二維座標射出一道直線，並判斷該射線所相交的物件。</p><h4 class="PostBodyBlock_h4__78VBA" id="plane-raycast">Plane.Raycast</h4><p>先從這個技術的最基本實作，也就是判斷滑鼠在純平面上的座標開始。</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">using UnityEngine;

public class GetMousePos : MonoBehaviour {
    Plane plane = new Plane (Vector3.up, 0);
    Camera camera;
    Vector3 mousePos;

    void Start () {
        camera = Camera.main;
    }

    void Update () {
        float distance;
        Ray ray = camera.ScreenPointToRay(Input.mousePosition);
        if(plane.Raycast(ray, out distance)){
            mousePos = ray.GetPoint(distance);
        }
    }
}</code></pre><p>一行一行解讀：</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">Plane plane = new Plane (Vector3.up, 0);</code></pre><p>從官方文件 <a href="https://docs.unity3d.com/ScriptReference/Plane-ctor.html" class="PostBodyBlock_link__faaEN" rel="noreferrer noopener" target="_blank">https://docs.unity3d.com/ScriptReference/Plane-ctor.html</a> 可以查到 Plane 的 constructor 是長這樣： <code class="PostBodyBlock_inline-code__TAzYM">Plane (Vector3 inNormal, float distance)</code> 。</p><p>以三維座標 (0, 0, 0) 為基準點，基於法線方向 <code class="PostBodyBlock_inline-code__TAzYM">inNormal</code> 在距離基準點 <code class="PostBodyBlock_inline-code__TAzYM">distance</code> 的位置創造一個平面。 <code class="PostBodyBlock_inline-code__TAzYM">Vector3.up</code> 就等於 <code class="PostBodyBlock_inline-code__TAzYM">Vector3 (0, 1, 0)</code> ，也就是筆直朝向 Y 軸上方的向量。這個 plane 不會顯示在遊戲中，如果想要用視覺理解 plane 的概念，可以直接在 Editor 中新增一個 rotation 與 position 都為 (0, 0, 0) 的 Plane，這兩個平面基本上相同。</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">   Camera camera;
   Vector3 mousePos;
   void Start () {
       camera = Camera.main;
   }</code></pre><p>將目前使用的主攝影機存為變數，並預先設立儲存滑鼠位置用的變數。</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">void Update () {
    float distance;
    Ray ray = camera.ScreenPointToRay(Input.mousePosition);
    ...</code></pre><p>在每次更新時，創建一個空的距離變數 <code class="PostBodyBlock_inline-code__TAzYM">distance</code> ，以及一個射線變數 <code class="PostBodyBlock_inline-code__TAzYM">ray</code> ，起點為攝影機的 near clipping plane，方向為滑鼠位置。</p><p>攝影機的顯示範圍是一個上窄下寬的梯形，頂部距離攝影機較近且面積較小的平面就是 near clipping plane，底部較遠較大的平面就是 far clipping plane。玩家所謂的遊戲視窗大小基本上就等於 near clipping plane， <code class="PostBodyBlock_inline-code__TAzYM">Camera.ScreenPointToRay</code> 也就是從 near clipping plane 射向 far clipping plane。</p><figure class="PostBodyBlock_figure__XY1Rs"><img alt="" src="/images/unity-dev-memo-1_1.png" width="600" height="400" decoding="async" data-nimg="1" class="PostBodyBlock_image__KsPkW" loading="lazy" style="color:transparent"></figure><p>這兩個數值都可以從 camera 的 inspector 調整。</p><figure class="PostBodyBlock_figure__XY1Rs"><img alt="" src="/images/unity-dev-memo-1_2.png" width="600" height="400" decoding="async" data-nimg="1" class="PostBodyBlock_image__KsPkW" loading="lazy" style="color:transparent"></figure><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">		...
		if(plane.Raycast(ray, out distance)){
        mousePos = ray.GetPoint(distance);
    }
}</code></pre><p>回到程式碼， <code class="PostBodyBlock_inline-code__TAzYM">plane.Raycast</code> 中的 <code class="PostBodyBlock_inline-code__TAzYM">out</code> 是另一個值得注意的地方。先看 <code class="PostBodyBlock_inline-code__TAzYM">plane.Raycast</code> 函數本身：</p><p><a href="https://docs.unity3d.com/ScriptReference/Plane.Raycast.html" class="PostBodyBlock_link__faaEN" rel="noreferrer noopener" target="_blank">https://docs.unity3d.com/ScriptReference/Plane.Raycast.html</a></p><p>這個函數的型別是 bool ，回傳引數 ray 是否與該 plane 相交。然而，部分函數提供額外的回傳值，取得值時必須提供一個空變數與 <code class="PostBodyBlock_inline-code__TAzYM">out</code> 關鍵字一起作為引數輸入。 <code class="PostBodyBlock_inline-code__TAzYM">plane.Raycast</code> 就是有提供 <code class="PostBodyBlock_inline-code__TAzYM">out</code> 回傳值的函數之一，提供的是當相交發生時從 ray 起點至相交點的距離 <code class="PostBodyBlock_inline-code__TAzYM">distance</code> 。因此這一段程式碼的作用是，判斷平面 plane 與 ray 是否有相交發生，如果有的話將距離儲存進 distance。現在射線起點，相交距離都知道了，就能計算出滑鼠位置便是從該射線上從起點開始距離 distance 的地方。</p><figure class="PostBodyBlock_figure__XY1Rs"><img alt="" src="/images/unity-dev-memo-2_3.gif" width="600" height="400" decoding="async" data-nimg="1" class="PostBodyBlock_image__KsPkW" loading="lazy" style="color:transparent"></figure><p>以上就是在射線上增加元素使其可視化之後的展示，紅色點是射線起點 (<code class="PostBodyBlock_inline-code__TAzYM">ray.GetPoint(0)</code> )，藍色點是與平面相交點（ <code class="PostBodyBlock_inline-code__TAzYM">ray.GetPoint(distance)</code> ）。可以看見起點不是攝影機本身，而是在 near clipping plane 上。</p><h4 class="PostBodyBlock_h4__78VBA" id="collider-raycast">Collider.Raycast</h4><p>以上都是純平面的情況，實際在遊戲中常常有地形非單純平面的情況，此時可以使用 <code class="PostBodyBlock_inline-code__TAzYM">TerrainCollider</code> 來計算射線與地形 terrain 的相交點。</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GetMousePos : MonoBehaviour {
    TerrainCollider terrainCollider;
    Camera camera;
    Vector3 mousePos;

    void Start () {
        camera = Camera.main;
        terrainCollider = Terrain.activeTerrain.GetComponent&lt;TerrainCollider&gt;();
    }

    void Update () {
        Ray ray = camera.ScreenPointToRay(Input.mousePosition);
        RaycastHit hitData;
        if(terrainCollider.Raycast(ray, out hitData, 1000)){
            mousePos = hitData.point;
        }
    }
}</code></pre><p>內容大致相同，只是這次判斷相交點的元素不是平面，而是地形碰撞體 <code class="PostBodyBlock_inline-code__TAzYM">terrainCollider</code> ，而這個函數所提供的 out 相交資料也更豐富，不只有距離，而是一整個資料形態 RaycastHit <a href="https://docs.unity3d.com/ScriptReference/RaycastHit.html" class="PostBodyBlock_link__faaEN" rel="noreferrer noopener" target="_blank">https://docs.unity3d.com/ScriptReference/RaycastHit.html</a> ，包含 point, distance ,collider 等，point 即為射線與 <code class="PostBodyBlock_inline-code__TAzYM">terrainCollider</code> 相交點。</p><figure class="PostBodyBlock_figure__XY1Rs"><img alt="" src="/images/unity-dev-memo-2_4.gif" width="600" height="400" decoding="async" data-nimg="1" class="PostBodyBlock_image__KsPkW" loading="lazy" style="color:transparent"></figure><p>上圖就是在不規則地形使用 <code class="PostBodyBlock_inline-code__TAzYM">terrainCollider.Raycast</code> 追蹤游標位置的展示，可以看見在右側遊戲畫面中游標移至山脈可見的南側時，左側的編輯器畫面也顯示游標位置的藍點直接跳過山脈北側，同時隨著地形一同起伏。</p><h4 class="PostBodyBlock_h4__78VBA" id="physics-raycast">Physics.Raycast</h4><p>以上兩種實作的前提都是射線相交的對象為特定單一物件。想要判斷射線是否相交非特定物件時，使用 <code class="PostBodyBlock_inline-code__TAzYM">Physics.Raycast</code> 。這個函數會抓取引數的射線相交的第一個對象，且同樣提供 <code class="PostBodyBlock_inline-code__TAzYM">out RaycastHit</code> 資料。</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GetMousePos : MonoBehaviour {
    Camera camera;
    Vector3 mousePos;

    void Start () {
        camera = Camera.main;
    }

    void Update () {
        Ray ray = camera.ScreenPointToRay(Input.mousePosition);
        RaycastHit hitData;
        if(Physics.Raycast(ray, out hitData, 1000)){
            mousePos = hitData.point;
						GameObject hitObj = hitData.collider.transform.gameObject;
        }
    }
}</code></pre><p><code class="PostBodyBlock_inline-code__TAzYM">Physics.Raycast</code> 的提供距離引數做為判斷相交的最大距離，可以依照自己需求設定。</p><p>![](unity-dev-memo-2_5 1.gif)</p><p>上圖為使用 <code class="PostBodyBlock_inline-code__TAzYM">Physics.Raycast</code> 追蹤游標互動物件的展示，使用 <code class="PostBodyBlock_inline-code__TAzYM">RaycastHit.collider.transform.GameObject</code> 判斷射線的碰撞體的原物件之後就可以進行互動。</p><h4 class="PostBodyBlock_h4__78VBA" id="layermask-in-physics-raycast">LayerMask in Physics.Raycast</h4><p><code class="PostBodyBlock_inline-code__TAzYM">Physics.Raycast</code> 還提供圖層引數過濾判斷射線相交對象。</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-csharp">using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class HighlightRayOrigin : MonoBehaviour {
    Camera camera;
    Vector3 mousePos;
    LayerMask layerMask = 1 &lt;&lt; 8;

    void Start () {
        camera = Camera.main;
    }

    void Update () {
        Ray ray = camera.ScreenPointToRay (Input.mousePosition);
        RaycastHit hitData;
        if (Physics.Raycast (ray, out hitData, 1000, layerMask)) {
            mousePos = hitData.point;
						GameObject hitObj = hitData.collider.transform.gameObject;
        }
    }
}</code></pre><p><code class="PostBodyBlock_inline-code__TAzYM">Physics.Raycast</code> 的 <code class="PostBodyBlock_inline-code__TAzYM">layerMask</code> 引數就是指定圖層，只有在這個圖層中的物件才會觸發與射線相交的判斷。</p><p>請注意，雖然這個引數的型別是 int，但其實是二進制的 int，所以直接輸入在編輯器中顯示的圖層編號是不會正常運作的，必須以 <code class="PostBodyBlock_inline-code__TAzYM">&lt;&lt;</code> 運算子將指定編號以二進制方式儲存在變數中再傳遞給 <code class="PostBodyBlock_inline-code__TAzYM">Physics.Raycast</code> 函數。</p><figure class="PostBodyBlock_figure__XY1Rs"><img alt="" src="/images/unity-dev-memo-2_6.gif" width="600" height="400" decoding="async" data-nimg="1" class="PostBodyBlock_image__KsPkW" loading="lazy" style="color:transparent"></figure><p>上圖是使用 LayerMask 過濾可互動物件的展示，只有上層物件位於可互動的圖層中，因此游標在地形或是下層物件時藍點都不會隨之移動。</p></article><div class="PostDetailPage_additional-list-container__b_oHL"><div class="AdditionalPostList_container__ucjfo"><div class="AdditionalPostList_category-link__EDTWa">More from<a href="/blog/archive/?category=note">note</a></div><div class="AdditionalPostList_card-list__jz3F_"><a class="AdditionalPostList_card__doJcw" href="/blog/thoughts-on-building-a-game-with-xstate/"><div><div class="AdditionalPostList_card-title__FDhSX">Thoughts on Building a Game with XState</div><div class="AdditionalPostList_card-description__Enc8v">After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 4, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/godot-essentials/"><div><div class="AdditionalPostList_card-title__FDhSX">Godot Essentials</div><div class="AdditionalPostList_card-description__Enc8v">The biggest lessons I learned in my first Godot project.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">April 21, 2024</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/unity-dev-memo-1/"><div><div class="AdditionalPostList_card-title__FDhSX">Unity Dev Memo (1)</div><div class="AdditionalPostList_card-description__Enc8v">關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">March 8, 2020</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/a-rather-easy-way-to-implement-quicksort-in-js/"><div><div class="AdditionalPostList_card-title__FDhSX">A Rather Easy Way to Implement Quicksort in JavaScript</div><div class="AdditionalPostList_card-description__Enc8v">My attempt to implement quicksort.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">May 23, 2019</div></a></div></div><div class="AdditionalPostList_container__ucjfo"><a class="AdditionalPostList_archive-link__7Q6ys" href="/blog/archive/">Archive</a><div class="AdditionalPostList_card-list__jz3F_"><a class="AdditionalPostList_card__doJcw" href="/blog/blogging-and-digital-gardening/"><div><div class="AdditionalPostList_card-title__FDhSX">Blogging and Digital Gardening in the Social Platform and Generative AI Era</div><div class="AdditionalPostList_card-description__Enc8v">I talk to myself about why bother writing at somewhere nobody comes.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">February 11, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/a-redemption-three-years-later/"><div><div class="AdditionalPostList_card-title__FDhSX">A Redemption Three Years Later</div><div class="AdditionalPostList_card-description__Enc8v">CD PROJEKT RED made a promise about Night City, which they broke. Three years later they had another attempt, and to me, it was their redemption.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 13, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/s14-recap/"><div><div class="AdditionalPostList_card-title__FDhSX">S14 Recap</div><div class="AdditionalPostList_card-description__Enc8v">I did not play a lot of league during 2024, but I had a few unforgettable moments nonetheless.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 7, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/thoughts-on-building-a-game-with-xstate/"><div><div class="AdditionalPostList_card-title__FDhSX">Thoughts on Building a Game with XState</div><div class="AdditionalPostList_card-description__Enc8v">After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 4, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/under-the-hood-diablo-ii-item-generation/"><div><div class="AdditionalPostList_card-title__FDhSX">Under the Hood: Diablo II Item Generation</div><div class="AdditionalPostList_card-description__Enc8v">A system design research turned into a reconciliation with a game I didn't know I was so in love with, so I wrote a research note to express my appreciation.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">November 8, 2024</div></a></div></div></div></div><div class="Layout_right-panel__zSn4t"><div class="TableOfContentColumn_container__0tmUV"><ul class="TableOfContentColumn_ul__7wuVs interactive-list-color"><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">Raycast</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">Plane.Raycast</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">Collider.Raycast</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">Physics.Raycast</button></li><li class="TableOfContentColumn_li__FUe4z"><div class="TableOfContentColumn_indent__CXWB4"></div><div class="TableOfContentColumn_indent__CXWB4"></div><button role="link" class="TableOfContentColumn_link__5qS3c">LayerMask in Physics.Raycast</button></li></ul></div></div><div class="SiteFooter_container__0v6cR border-color"><a href="https://asukawang.com" rel="noopener noreferrer" target="_blank" class="SiteFooter_link__RuMSe interactive-color">asukawang.com 2018-</a></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postContent":[{"type":"heading","children":[{"type":"plain","text":"Raycast"}],"depth":2},{"type":"paragraph","children":[{"type":"plain","text":"在使用滑鼠的 3D 遊戲中，幾乎與任何物件互動都需要使用滑鼠，判斷玩家游標的位置自然是非常重要且基礎的技術。然而相對 3D 世界的三維座標，存在於螢幕上的游標只有二維座標的 X 軸與 Y 軸兩個數據代表位置，這使得在遊戲世界中精準定位游標位置變得困難。"}]},{"type":"paragraph","children":[{"type":"plain","text":"不過，大多數想要在遊戲中取得游標位置時，都是為了與存在該位置的物件互動。這個物件就能成為定位游標的輔助工具，只要計算從玩家視角中的游標，是否真正與遊戲世界中的該物件重合即可。"}]},{"type":"paragraph","children":[{"type":"plain","text":"具體來說，這個判斷方式是從攝影機朝向滑鼠的二維座標射出一道直線，並判斷該射線所相交的物件。"}]},{"type":"heading","children":[{"type":"plain","text":"Plane.Raycast"}],"depth":3},{"type":"paragraph","children":[{"type":"plain","text":"先從這個技術的最基本實作，也就是判斷滑鼠在純平面上的座標開始。"}]},{"type":"code","lang":"csharp","text":"using UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    Plane plane = new Plane (Vector3.up, 0);\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        float distance;\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        if(plane.Raycast(ray, out distance)){\n            mousePos = ray.GetPoint(distance);\n        }\n    }\n}"},{"type":"paragraph","children":[{"type":"plain","text":"一行一行解讀："}]},{"type":"code","lang":"csharp","text":"Plane plane = new Plane (Vector3.up, 0);"},{"type":"paragraph","children":[{"type":"plain","text":"從官方文件 "},{"type":"link","text":"https://docs.unity3d.com/ScriptReference/Plane-ctor.html","url":"https://docs.unity3d.com/ScriptReference/Plane-ctor.html"},{"type":"plain","text":" 可以查到 Plane 的 constructor 是長這樣： "},{"type":"inlineCode","text":"Plane (Vector3 inNormal, float distance)"},{"type":"plain","text":" 。"}]},{"type":"paragraph","children":[{"type":"plain","text":"以三維座標 (0, 0, 0) 為基準點，基於法線方向 "},{"type":"inlineCode","text":"inNormal"},{"type":"plain","text":" 在距離基準點 "},{"type":"inlineCode","text":"distance"},{"type":"plain","text":" 的位置創造一個平面。 "},{"type":"inlineCode","text":"Vector3.up"},{"type":"plain","text":" 就等於 "},{"type":"inlineCode","text":"Vector3 (0, 1, 0)"},{"type":"plain","text":" ，也就是筆直朝向 Y 軸上方的向量。這個 plane 不會顯示在遊戲中，如果想要用視覺理解 plane 的概念，可以直接在 Editor 中新增一個 rotation 與 position 都為 (0, 0, 0) 的 Plane，這兩個平面基本上相同。"}]},{"type":"code","lang":"csharp","text":"   Camera camera;\n   Vector3 mousePos;\n   void Start () {\n       camera = Camera.main;\n   }"},{"type":"paragraph","children":[{"type":"plain","text":"將目前使用的主攝影機存為變數，並預先設立儲存滑鼠位置用的變數。"}]},{"type":"code","lang":"csharp","text":"void Update () {\n    float distance;\n    Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n    ..."},{"type":"paragraph","children":[{"type":"plain","text":"在每次更新時，創建一個空的距離變數 "},{"type":"inlineCode","text":"distance"},{"type":"plain","text":" ，以及一個射線變數 "},{"type":"inlineCode","text":"ray"},{"type":"plain","text":" ，起點為攝影機的 near clipping plane，方向為滑鼠位置。"}]},{"type":"paragraph","children":[{"type":"plain","text":"攝影機的顯示範圍是一個上窄下寬的梯形，頂部距離攝影機較近且面積較小的平面就是 near clipping plane，底部較遠較大的平面就是 far clipping plane。玩家所謂的遊戲視窗大小基本上就等於 near clipping plane， "},{"type":"inlineCode","text":"Camera.ScreenPointToRay"},{"type":"plain","text":" 也就是從 near clipping plane 射向 far clipping plane。"}]},{"type":"image","caption":null,"url":"unity-dev-memo-1_1.png","alt":""},{"type":"paragraph","children":[{"type":"plain","text":"這兩個數值都可以從 camera 的 inspector 調整。"}]},{"type":"image","caption":null,"url":"unity-dev-memo-1_2.png","alt":""},{"type":"code","lang":"csharp","text":"\t\t...\n\t\tif(plane.Raycast(ray, out distance)){\n        mousePos = ray.GetPoint(distance);\n    }\n}"},{"type":"paragraph","children":[{"type":"plain","text":"回到程式碼， "},{"type":"inlineCode","text":"plane.Raycast"},{"type":"plain","text":" 中的 "},{"type":"inlineCode","text":"out"},{"type":"plain","text":" 是另一個值得注意的地方。先看 "},{"type":"inlineCode","text":"plane.Raycast"},{"type":"plain","text":" 函數本身："}]},{"type":"paragraph","children":[{"type":"link","text":"https://docs.unity3d.com/ScriptReference/Plane.Raycast.html","url":"https://docs.unity3d.com/ScriptReference/Plane.Raycast.html"}]},{"type":"paragraph","children":[{"type":"plain","text":"這個函數的型別是 bool ，回傳引數 ray 是否與該 plane 相交。然而，部分函數提供額外的回傳值，取得值時必須提供一個空變數與 "},{"type":"inlineCode","text":"out"},{"type":"plain","text":" 關鍵字一起作為引數輸入。 "},{"type":"inlineCode","text":"plane.Raycast"},{"type":"plain","text":" 就是有提供 "},{"type":"inlineCode","text":"out"},{"type":"plain","text":" 回傳值的函數之一，提供的是當相交發生時從 ray 起點至相交點的距離 "},{"type":"inlineCode","text":"distance"},{"type":"plain","text":" 。因此這一段程式碼的作用是，判斷平面 plane 與 ray 是否有相交發生，如果有的話將距離儲存進 distance。現在射線起點，相交距離都知道了，就能計算出滑鼠位置便是從該射線上從起點開始距離 distance 的地方。"}]},{"type":"image","caption":null,"url":"unity-dev-memo-2_3.gif","alt":""},{"type":"paragraph","children":[{"type":"plain","text":"以上就是在射線上增加元素使其可視化之後的展示，紅色點是射線起點 ("},{"type":"inlineCode","text":"ray.GetPoint(0)"},{"type":"plain","text":" )，藍色點是與平面相交點（ "},{"type":"inlineCode","text":"ray.GetPoint(distance)"},{"type":"plain","text":" ）。可以看見起點不是攝影機本身，而是在 near clipping plane 上。"}]},{"type":"heading","children":[{"type":"plain","text":"Collider.Raycast"}],"depth":3},{"type":"paragraph","children":[{"type":"plain","text":"以上都是純平面的情況，實際在遊戲中常常有地形非單純平面的情況，此時可以使用 "},{"type":"inlineCode","text":"TerrainCollider"},{"type":"plain","text":" 來計算射線與地形 terrain 的相交點。"}]},{"type":"code","lang":"csharp","text":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    TerrainCollider terrainCollider;\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n        terrainCollider = Terrain.activeTerrain.GetComponent\u003cTerrainCollider\u003e();\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hitData;\n        if(terrainCollider.Raycast(ray, out hitData, 1000)){\n            mousePos = hitData.point;\n        }\n    }\n}"},{"type":"paragraph","children":[{"type":"plain","text":"內容大致相同，只是這次判斷相交點的元素不是平面，而是地形碰撞體 "},{"type":"inlineCode","text":"terrainCollider"},{"type":"plain","text":" ，而這個函數所提供的 out 相交資料也更豐富，不只有距離，而是一整個資料形態 RaycastHit "},{"type":"link","text":"https://docs.unity3d.com/ScriptReference/RaycastHit.html","url":"https://docs.unity3d.com/ScriptReference/RaycastHit.html"},{"type":"plain","text":" ，包含 point, distance ,collider 等，point 即為射線與 "},{"type":"inlineCode","text":"terrainCollider"},{"type":"plain","text":" 相交點。"}]},{"type":"image","caption":null,"url":"unity-dev-memo-2_4.gif","alt":""},{"type":"paragraph","children":[{"type":"plain","text":"上圖就是在不規則地形使用 "},{"type":"inlineCode","text":"terrainCollider.Raycast"},{"type":"plain","text":" 追蹤游標位置的展示，可以看見在右側遊戲畫面中游標移至山脈可見的南側時，左側的編輯器畫面也顯示游標位置的藍點直接跳過山脈北側，同時隨著地形一同起伏。"}]},{"type":"heading","children":[{"type":"plain","text":"Physics.Raycast"}],"depth":3},{"type":"paragraph","children":[{"type":"plain","text":"以上兩種實作的前提都是射線相交的對象為特定單一物件。想要判斷射線是否相交非特定物件時，使用 "},{"type":"inlineCode","text":"Physics.Raycast"},{"type":"plain","text":" 。這個函數會抓取引數的射線相交的第一個對象，且同樣提供 "},{"type":"inlineCode","text":"out RaycastHit"},{"type":"plain","text":" 資料。"}]},{"type":"code","lang":"csharp","text":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hitData;\n        if(Physics.Raycast(ray, out hitData, 1000)){\n            mousePos = hitData.point;\n\t\t\t\t\t\tGameObject hitObj = hitData.collider.transform.gameObject;\n        }\n    }\n}"},{"type":"paragraph","children":[{"type":"inlineCode","text":"Physics.Raycast"},{"type":"plain","text":" 的提供距離引數做為判斷相交的最大距離，可以依照自己需求設定。"}]},{"type":"paragraph","children":[{"type":"plain","text":"![](unity-dev-memo-2_5 1.gif)"}]},{"type":"paragraph","children":[{"type":"plain","text":"上圖為使用 "},{"type":"inlineCode","text":"Physics.Raycast"},{"type":"plain","text":" 追蹤游標互動物件的展示，使用 "},{"type":"inlineCode","text":"RaycastHit.collider.transform.GameObject"},{"type":"plain","text":" 判斷射線的碰撞體的原物件之後就可以進行互動。"}]},{"type":"heading","children":[{"type":"plain","text":"LayerMask in Physics.Raycast"}],"depth":3},{"type":"paragraph","children":[{"type":"inlineCode","text":"Physics.Raycast"},{"type":"plain","text":" 還提供圖層引數過濾判斷射線相交對象。"}]},{"type":"code","lang":"csharp","text":"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class HighlightRayOrigin : MonoBehaviour {\n    Camera camera;\n    Vector3 mousePos;\n    LayerMask layerMask = 1 \u003c\u003c 8;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay (Input.mousePosition);\n        RaycastHit hitData;\n        if (Physics.Raycast (ray, out hitData, 1000, layerMask)) {\n            mousePos = hitData.point;\n\t\t\t\t\t\tGameObject hitObj = hitData.collider.transform.gameObject;\n        }\n    }\n}"},{"type":"paragraph","children":[{"type":"inlineCode","text":"Physics.Raycast"},{"type":"plain","text":" 的 "},{"type":"inlineCode","text":"layerMask"},{"type":"plain","text":" 引數就是指定圖層，只有在這個圖層中的物件才會觸發與射線相交的判斷。"}]},{"type":"paragraph","children":[{"type":"plain","text":"請注意，雖然這個引數的型別是 int，但其實是二進制的 int，所以直接輸入在編輯器中顯示的圖層編號是不會正常運作的，必須以 "},{"type":"inlineCode","text":"\u003c\u003c"},{"type":"plain","text":" 運算子將指定編號以二進制方式儲存在變數中再傳遞給 "},{"type":"inlineCode","text":"Physics.Raycast"},{"type":"plain","text":" 函數。"}]},{"type":"image","caption":null,"url":"unity-dev-memo-2_6.gif","alt":""},{"type":"paragraph","children":[{"type":"plain","text":"上圖是使用 LayerMask 過濾可互動物件的展示，只有上層物件位於可互動的圖層中，因此游標在地形或是下層物件時藍點都不會隨之移動。"}]}],"postMetadata":{"id":"unity-dev-memo-2","title":"Unity Dev Memo (2)","description":"關於 Unity3D 內 raycast 的研究筆記。","category":"note","topic":"game development","tags":[],"publishDate":"2020-10-04","pathname":"unity-dev-memo-2"},"last5posts":[{"id":"blogging-and-digital-gardening","title":"Blogging and Digital Gardening in the Social Platform and Generative AI Era","description":"I talk to myself about why bother writing at somewhere nobody comes.","category":"essay","topic":"life","tags":[],"publishDate":"2025-02-11","pathname":"blogging-and-digital-gardening"},{"id":"a-redemption-three-years-later","title":"A Redemption Three Years Later","description":"CD PROJEKT RED made a promise about Night City, which they broke. Three years later they had another attempt, and to me, it was their redemption.","category":"review","topic":"gaming","tags":[],"publishDate":"2025-01-13","pathname":"a-redemption-three-years-later"},{"id":"s14-recap","title":"S14 Recap","description":"I did not play a lot of league during 2024, but I had a few unforgettable moments nonetheless.","category":"retrospective","topic":"gaming","tags":[],"publishDate":"2025-01-07","pathname":"s14-recap"},{"id":"thoughts-on-building-a-game-with-xstate","title":"Thoughts on Building a Game with XState","description":"After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.","category":"note","topic":"game development","tags":[],"publishDate":"2025-01-04","pathname":"thoughts-on-building-a-game-with-xstate"},{"id":"under-the-hood-diablo-ii-item-generation","title":"Under the Hood: Diablo II Item Generation","description":"A system design research turned into a reconciliation with a game I didn't know I was so in love with, so I wrote a research note to express my appreciation.","category":"research","topic":"game development","tags":[],"publishDate":"2024-11-08","pathname":"under-the-hood-diablo-ii-item-generation"}],"categoryPosts":[{"id":"thoughts-on-building-a-game-with-xstate","title":"Thoughts on Building a Game with XState","description":"After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.","category":"note","topic":"game development","tags":[],"publishDate":"2025-01-04","pathname":"thoughts-on-building-a-game-with-xstate"},{"id":"godot-essentials","title":"Godot Essentials","description":"The biggest lessons I learned in my first Godot project.","category":"note","topic":"game development","tags":[],"publishDate":"2024-04-21","pathname":"godot-essentials"},{"id":"unity-dev-memo-1","title":"Unity Dev Memo (1)","description":"關於 Unity3D 物體移動，腳本執行順序以及 Hitbox 的筆記。","category":"note","topic":"game development","tags":[],"publishDate":"2020-03-08","pathname":"unity-dev-memo-1"},{"id":"a-rather-easy-way-to-implement-quicksort-in-js","title":"A Rather Easy Way to Implement Quicksort in JavaScript","description":"My attempt to implement quicksort.","category":"note","topic":"programming","tags":[],"publishDate":"2019-05-23","pathname":"a-rather-easy-way-to-implement-quicksort-in-js"}],"categories":[{"name":"essay","count":12},{"name":"review","count":15},{"name":"retrospective","count":15},{"name":"note","count":9},{"name":"research","count":3}]},"__N_SSG":true},"page":"/blog/[pathname]","query":{"pathname":"unity-dev-memo-2"},"buildId":"4Ynmg8plvSU9VjJd-mk9l","isFallback":false,"gsp":true,"scriptLoader":[]}</script><script>(function(){var el=document.createElement('link');el.href='/subfont/fallback-1f9f028477.css';el.rel='stylesheet';document.body.appendChild(el)}())</script><noscript><link rel="stylesheet" href="/subfont/fallback-1f9f028477.css"></noscript></body></html>
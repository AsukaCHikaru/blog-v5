<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><title>Full-Screen Scroll | Asuka Wang</title><meta name="description" content="Research notes of implementing full-screen scroll animation."><meta property="og:title" content="Full-Screen Scroll | Asuka Wang"><meta property="twitter:title" content="Full-Screen Scroll | Asuka Wang"><meta name="next-head-count" content="6"><link rel="preload" href="/_next/static/css/3cdbb22e386a6252.css" as="style"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Serif_JP_CJK-200-ef83f20108.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Serif_JP-200-6411997352.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Gentium_Plus-400-62b8f514fb.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Serif_JP_CJK-400-a9cf5e5b7a.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Serif_JP-400-8da275ef5e.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Gentium_Plus_Book-700-47a76121c3.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="anonymous" href="/subfont/Noto_Sans-400-fa7c89e361.woff2"><link rel="stylesheet" href="/subfont/fonts-6bd80b1bc8.css"><link rel="stylesheet" href="/_next/static/css/3cdbb22e386a6252.css" data-n-g=""><link rel="preload" href="/_next/static/css/daa64173e9621645.css" as="style"><link rel="stylesheet" href="/_next/static/css/daa64173e9621645.css" data-n-p=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-f2ca60db2beb93ed.js" defer=""></script><script src="/_next/static/chunks/pages/_app-95f49e67a22d34df.js" defer=""></script><script src="/_next/static/chunks/542-7be5b5539309fe0b.js" defer=""></script><script src="/_next/static/chunks/808-a6cf6746eaf986b0.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bpathname%5D-14232e8fa7e9c453.js" defer=""></script><script src="/_next/static/K8ZbhF-RP2WBtco10lfGC/_buildManifest.js" defer=""></script><script src="/_next/static/K8ZbhF-RP2WBtco10lfGC/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main><div class="text-color Layout_container__S4aNf" data-is-menu-open="false"><div class="SiteHeader_container__8tKwA" data-is-menu-open="false"><div class="SiteHeader_nav-container__oEq2d"><div class="SiteHeader_section-container__tAKnZ"><a class="SiteHeader_section-link__9DmFE interactive-color text-color" href="/blog/">blog</a><a class="SiteHeader_section-link__9DmFE interactive-color " href="/about/">about</a><a target="_blank" class="SiteHeader_section-link__9DmFE interactive-color" href="/blog/feed.xml">rss</a></div><button class="SiteHeader_menu-button__eK9ND">menu</button><a class="SiteHeader_publication-folio___ZFZS text-color" href="/">ASUKA WANG</a></div><div class="SiteHeader_divider__cq_R_ border-color-100"></div><div class="SiteHeader_menu-wrapper__2evr7"></div></div><div class="Layout_full-content__MQIxS"><div class="PostDetailPageHeader_container__fcMw9"><div class="Layout_main-content__mr9_2"><h1 class="PostDetailPageHeader_title__YwZEK">Full-Screen Scroll</h1><h2 class="PostDetailPageHeader_description__HSXhn">Research notes of implementing full-screen scroll animation.</h2><div class="PostDetailPageHeader_publish-date__pMF22">February 11, 2021</div></div></div></div><div class="Layout_main-content__mr9_2"><article class="PostDetailPage_article__K8T4B"><h3 class="PostBodyBlock_h3__BUDla" id="tl;dr:">TL;DR:</h3><ul class="PostBodyBlock_ul__QtcuL"><li><code class="PostBodyBlock_inline-code__TAzYM">overflow-y: hidden</code> for html and body, and <code class="PostBodyBlock_inline-code__TAzYM">overflow-y: scroll</code> for the scroller element</li><li>Use recursive <code class="PostBodyBlock_inline-code__TAzYM">window.requestAnimationFrame</code> to set <code class="PostBodyBlock_inline-code__TAzYM">scrollTop</code></li></ul><p>In my latest project&nbsp;<a href="https://2020.musicawards.asukachikaru.com/" class="PostBodyBlock_link__faaEN" rel="noreferrer noopener" target="_blank">CHIKA Music Awards 2020</a>&nbsp;I focused more on user experience and visual effects. One of the features I used to achieve that was full-screen scrolling.</p><p>First, let's talk about the definition of full-screen scrolling. In short, it looks like this:</p><figure class="PostBodyBlock_figure__XY1Rs"><img alt="" src="/images/full-screen-scroll_1.gif" width="600" height="400" decoding="async" data-nimg="1" class="PostBodyBlock_image__KsPkW" loading="lazy" style="color:transparent"></figure><p>And the literal definition of full-screen scrolling includes the below specs:</p><ul class="PostBodyBlock_ul__QtcuL"><li>Triggered by scroll or touchmove events</li><li>The scroll distance equal to visible area height</li><li>Smooth scrolling</li><li>Scroll exactly one page every time, no scroll momentum</li></ul><p>Some libraries have taken care of the problem for me, but as a side project, I try to challenge myself as much as possible instead of only focusing on getting things done. So I implemented full-page scrolling from scratch. I used Vue3 for this project, but the idea should be universal.</p><h3 class="PostBodyBlock_h3__BUDla" id="triggering-the-event">Triggering the event</h3><p>Obviously, we need <code class="PostBodyBlock_inline-code__TAzYM">scroll</code> event. But in mobile devices, we should use <code class="PostBodyBlock_inline-code__TAzYM">touchmove</code> event.</p><p>The concept of detecting the scrolling direction is simple: when the event fires for the first time, save the scroller element <code class="PostBodyBlock_inline-code__TAzYM">scrollTop</code> value (or the touch <code class="PostBodyBlock_inline-code__TAzYM">screenY</code> value in the <code class="PostBodyBlock_inline-code__TAzYM">touchmove</code> event). During the second time, compare the values to the previous ones.</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-js">// Add event listener. Or you can bind them to the component directly in Vue or React
document.querySelector(".scroll").addEventListener("scroll", handleScroll);

// Necessary variables for the event callback.
// I placed them here for clarity.
// Place them anywhere that fits the architecture of your project.
let scroller; // the scroller element
let currentY; // the current scrollTop of the scroller
let currentPageY; // the y value of the current page
let scrollDirection; // 1 or -1
let isScrolling;

// The event callback
const handleScroll = (e) =&gt; {
  // for scroll we don't need the event argument,
  // but for touchmove event callback we have to use it for the touch y value
  if (!scroller) {
    return;
  }

  currentY = scroller.scrollTop;
  // currentY = e.touches[0].screenY; for touchmove

  if (!isScrolling &amp;&amp; currentY !== currentPageY) {
    if (currentY &gt; currentPageY) {
      scrollDirection = -1;
    }
    if (currentY &lt; currentPageY) {
      scrollDirection = 1;
    }
    isScrolling = true;
    window.requestAnimationFrame(scrollTo);
  }
};</code></pre><h3 class="PostBodyBlock_h3__BUDla" id="get-scroll-height">Get scroll height</h3><p>First, prepare a scroller element. The scroller should contain all of the contents, and the height should be 100% of the visible area height.</p><p>For PC, this is easy: set the scroller's height (and all of its ancestors') to <code class="PostBodyBlock_inline-code__TAzYM">100vh</code>, then get <code class="PostBodyBlock_inline-code__TAzYM">window.innerHeight</code>, and we should be good. But for mobile devices, we have to deal with the problem that the browser address bar might hide during scrolling, which causes the visible area height to be inconsistent.</p><p><a href="https://github.com/bokand/root-scroller/blob/master/explainer.md" class="PostBodyBlock_link__faaEN" rel="noreferrer noopener" target="_blank">The URL bar hides when the root element scrolls down</a>, in which the root element means the <code class="PostBodyBlock_inline-code__TAzYM">&lt;html&gt;</code> element. Therefore, to avoid URL bar hides during scrolling, it is necessary to prevent root element from scrolling while scrolling the contents.</p><p>According to the&nbsp;<a href="https://www.w3.org/TR/CSS2/visufx.html#overflow" class="PostBodyBlock_link__faaEN" rel="noreferrer noopener" target="_blank">standard CSS overflow definition</a>, by default both <code class="PostBodyBlock_inline-code__TAzYM">&lt;html&gt;</code> and <code class="PostBodyBlock_inline-code__TAzYM">&lt;body&gt;</code> has <code class="PostBodyBlock_inline-code__TAzYM">overflow: auto</code>. Set both to <code class="PostBodyBlock_inline-code__TAzYM">overflow: hidden</code> , and we locked up <code class="PostBodyBlock_inline-code__TAzYM">&lt;html&gt;</code> and <code class="PostBodyBlock_inline-code__TAzYM">&lt;body&gt;</code> for good.</p><p>The next step is to give the scroller <code class="PostBodyBlock_inline-code__TAzYM">overflow: scroll</code>. Now when you scroll the viewport, <code class="PostBodyBlock_inline-code__TAzYM">&lt;html&gt;</code> and <code class="PostBodyBlock_inline-code__TAzYM">&lt;body&gt;</code> don't move at all, only the scroller is scrolling, and the URL bar will not hide. Notice that if there are any container elements between the scroller and the body, their overflow values also need to be <code class="PostBodyBlock_inline-code__TAzYM">hidden</code>.</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-css">html {
  height: 100vh;
  overflow-y: hidden;
}

body {
  height: 100%;
  overflow-y: hidden;
}

.scroller {
  height: 100%;
  overflow-y: scroll;
}</code></pre><p>The visible area height should be consistent now, and we should get window height without too much trouble.</p><h3 class="PostBodyBlock_h3__BUDla" id="smooth-scrolling">Smooth scrolling</h3><p><code class="PostBodyBlock_inline-code__TAzYM">.scrollTo</code> is initiative and efficient, but it's not very reliable. I've encountered scenarios that it wouldn't work (no effect at all). I haven't discovered the root cause, but it feels like <code class="PostBodyBlock_inline-code__TAzYM">.scrollTo</code> gets canceled when called too frequently.</p><p>I gave up the one-liner and went for another approach:&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" class="PostBodyBlock_link__faaEN" rel="noreferrer noopener" target="_blank">window.requestAnimationFrame</a>. This function prepares a frame to execute all the things inside the callback. This approach is inspired by <a href="https://github.com/rigor789/vue-scrollto" class="PostBodyBlock_link__faaEN" rel="noreferrer noopener" target="_blank">vue-scrollto</a>.</p><p>The callback has a single argument timestamp: <code class="PostBodyBlock_inline-code__TAzYM">DOMHighResTimeStamp</code>, which is essentially a number. When scroll animation starts, save the initial timestamp and then compare the timestamp in each call with the initial timestamp to determine if the elapsed time has exceeded the designated scroll animation duration. If the scroll is not finished yet, call <code class="PostBodyBlock_inline-code__TAzYM">window.requestAnimationFrame</code> inside the callback recursively.</p><p>For the scroll effect, set the scroller's scrollTop directly.</p><p><code class="PostBodyBlock_inline-code__TAzYM">scroller.scrollTop = {the y position after each scroll step}</code></p><p><code class="PostBodyBlock_inline-code__TAzYM">scroll-behavior: "smooth"</code> doesn't apply when changing a div's <code class="PostBodyBlock_inline-code__TAzYM">scrollTop</code> value in this way; this is why we need to use <code class="PostBodyBlock_inline-code__TAzYM">requestAnimationFrame</code> to create an animation.</p><pre class="CodeBlock_block__wRht1"><code class="CodeBlock_code__1aD9x language-js">let scrollDuration;
let scrollDirection; // 1 or -1
let scrollStartTime;
let scroller;
let currentY;
let scrollDistance; // window height, likely 100vh
let isScrolling;

const scrollTo = (timestamp: DOMHighResTimeStamp) =&gt; {
  if (!scrollStartTime) {
    scrollStartTime = timestamp;
  }

  const elapsedTime = timestamp - scrollStartTime;
  const progress = Math.min(elapsedTime / scrollDuration, 1);
  scroller.scrollTop = currentY + scrollDistance * progress * scrollDirection;

  if (elapsedTime &lt; duration) {
    window.requestAnimationFrame(scrollTo);
  } else {
    currentY = scroller.scrollTop;
    scrollStartTime = undefined;
    scrollDirection = undefined;
    isScrolling = false;
  }
};</code></pre><h3 class="PostBodyBlock_h3__BUDla" id="remove-the-momentum">Remove the momentum</h3><p>When the user scrolls the screen hence triggers the <code class="PostBodyBlock_inline-code__TAzYM">scroll</code> or <code class="PostBodyBlock_inline-code__TAzYM">touchmove</code> event, it's unlikely that the event only fires once. We can have the conditioning to prevent our full-screen scroll from repeatedly called, but the other scrolls caused by the user's finger remains, even after the full-screen scroll finishes. Removing the scroll momentum is the necessary polishing for the full-screen scroll effect.</p><p>There are two ways to disable scroll temporarily: <code class="PostBodyBlock_inline-code__TAzYM">pointerEvent: none</code>, and —you might have guessed it— <code class="PostBodyBlock_inline-code__TAzYM">overflow: hidden</code>. I found overflow more reliable, for <code class="PostBodyBlock_inline-code__TAzYM">pointerEvent</code> didn't work in some <code class="PostBodyBlock_inline-code__TAzYM">touchmove</code> scenario.</p><p>When the scroll starts (calling <code class="PostBodyBlock_inline-code__TAzYM">window.requestAnimationFrame</code> for the first time), add the above CSS property to the scroller element, and all the scrolls that after the first callback should take no effect. Thus we removed the momentum successfully.</p><hr class="PostBodyBlock_br__HpKdA border-color"><p>I finished the full-screen scroll effect with the above approach. It works fine in macOS, win, and mobile platforms. I believe there are other ways to do this, but I'm quite happy with the result I came up with.</p></article><div class="PostDetailPage_additional-list-container__b_oHL"><div class="AdditionalPostList_container__ucjfo"><div class="AdditionalPostList_category-link__EDTWa">More from<a href="/blog/archive/?category=research">research</a></div><div class="AdditionalPostList_card-list__jz3F_"><a class="AdditionalPostList_card__doJcw" href="/blog/under-the-hood-diablo-ii-item-generation/"><div><div class="AdditionalPostList_card-title__FDhSX">Under the Hood: Diablo II Item Generation</div><div class="AdditionalPostList_card-description__Enc8v">A system design research turned into a reconciliation with a game I didn't know I was so in love with, so I wrote a research note to express my appreciation.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">November 8, 2024</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/nextjs-app-font-not-loaded-on-remote-machine-issue/"><div><div class="AdditionalPostList_card-title__FDhSX">Next.js App Font Not Loaded on Remote Machine Issue</div><div class="AdditionalPostList_card-description__Enc8v">Debugging note of a source loading issue that never reproduces on the dev machine.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">June 5, 2023</div></a></div></div><div class="AdditionalPostList_container__ucjfo"><a class="AdditionalPostList_archive-link__7Q6ys" href="/blog/archive/">Archive</a><div class="AdditionalPostList_card-list__jz3F_"><a class="AdditionalPostList_card__doJcw" href="/blog/observation-on-programming-with-ai/"><div><div class="AdditionalPostList_card-title__FDhSX">Observation on Programming with AI</div><div class="AdditionalPostList_card-description__Enc8v">I reckoned getting familiar with AI coding tools is necessary, tried some, and to my surprise, I turned out to be quite optimistic.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">March 13, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/blogging-and-digital-gardening/"><div><div class="AdditionalPostList_card-title__FDhSX">Blogging and Digital Gardening in the Social Platform and Generative AI Era</div><div class="AdditionalPostList_card-description__Enc8v">I talk to myself about why bother writing at somewhere nobody comes.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">February 11, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/a-redemption-three-years-later/"><div><div class="AdditionalPostList_card-title__FDhSX">A Redemption Three Years Later</div><div class="AdditionalPostList_card-description__Enc8v">CD PROJEKT RED made a promise about Night City, which they broke. Three years later they had another attempt, and to me, it was their redemption.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 13, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/s14-recap/"><div><div class="AdditionalPostList_card-title__FDhSX">S14 Recap</div><div class="AdditionalPostList_card-description__Enc8v">I did not play a lot of league during 2024, but I had a few unforgettable moments nonetheless.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 7, 2025</div></a><a class="AdditionalPostList_card__doJcw" href="/blog/thoughts-on-building-a-game-with-xstate/"><div><div class="AdditionalPostList_card-title__FDhSX">Thoughts on Building a Game with XState</div><div class="AdditionalPostList_card-description__Enc8v">After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.</div></div><div class="AdditionalPostList_card-publish-date__Jvdgm">January 4, 2025</div></a></div></div></div></div><div class="SiteFooter_container__0v6cR border-color"><a href="https://asukawang.com" rel="noopener noreferrer" target="_blank" class="SiteFooter_link__RuMSe interactive-color">asukawang.com 2018-</a></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postContent":[{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"TL;DR:"}]},{"type":"list","ordered":false,"items":[{"type":"listItem","body":[{"type":"textBody","style":"code","value":"overflow-y: hidden"},{"type":"textBody","style":"plain","value":" for html and body, and "},{"type":"textBody","style":"code","value":"overflow-y: scroll"},{"type":"textBody","style":"plain","value":" for the scroller element"}]},{"type":"listItem","body":[{"type":"textBody","style":"plain","value":"Use recursive "},{"type":"textBody","style":"code","value":"window.requestAnimationFrame"},{"type":"textBody","style":"plain","value":" to set "},{"type":"textBody","style":"code","value":"scrollTop"}]}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"In my latest project "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"CHIKA Music Awards 2020"}],"url":"https://2020.musicawards.asukachikaru.com/"},{"type":"textBody","style":"plain","value":" I focused more on user experience and visual effects. One of the features I used to achieve that was full-screen scrolling."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"First, let's talk about the definition of full-screen scrolling. In short, it looks like this:"}]},{"type":"image","url":"full-screen-scroll_1.gif","altText":"","caption":""},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"And the literal definition of full-screen scrolling includes the below specs:"}]},{"type":"list","ordered":false,"items":[{"type":"listItem","body":[{"type":"textBody","style":"plain","value":"Triggered by scroll or touchmove events"}]},{"type":"listItem","body":[{"type":"textBody","style":"plain","value":"The scroll distance equal to visible area height"}]},{"type":"listItem","body":[{"type":"textBody","style":"plain","value":"Smooth scrolling"}]},{"type":"listItem","body":[{"type":"textBody","style":"plain","value":"Scroll exactly one page every time, no scroll momentum"}]}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Some libraries have taken care of the problem for me, but as a side project, I try to challenge myself as much as possible instead of only focusing on getting things done. So I implemented full-page scrolling from scratch. I used Vue3 for this project, but the idea should be universal."}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Triggering the event"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"Obviously, we need "},{"type":"textBody","style":"code","value":"scroll"},{"type":"textBody","style":"plain","value":" event. But in mobile devices, we should use "},{"type":"textBody","style":"code","value":"touchmove"},{"type":"textBody","style":"plain","value":" event."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"The concept of detecting the scrolling direction is simple: when the event fires for the first time, save the scroller element "},{"type":"textBody","style":"code","value":"scrollTop"},{"type":"textBody","style":"plain","value":" value (or the touch "},{"type":"textBody","style":"code","value":"screenY"},{"type":"textBody","style":"plain","value":" value in the "},{"type":"textBody","style":"code","value":"touchmove"},{"type":"textBody","style":"plain","value":" event). During the second time, compare the values to the previous ones."}]},{"type":"code","lang":"js","body":"// Add event listener. Or you can bind them to the component directly in Vue or React\ndocument.querySelector(\".scroll\").addEventListener(\"scroll\", handleScroll);\n\n// Necessary variables for the event callback.\n// I placed them here for clarity.\n// Place them anywhere that fits the architecture of your project.\nlet scroller; // the scroller element\nlet currentY; // the current scrollTop of the scroller\nlet currentPageY; // the y value of the current page\nlet scrollDirection; // 1 or -1\nlet isScrolling;\n\n// The event callback\nconst handleScroll = (e) =\u003e {\n  // for scroll we don't need the event argument,\n  // but for touchmove event callback we have to use it for the touch y value\n  if (!scroller) {\n    return;\n  }\n\n  currentY = scroller.scrollTop;\n  // currentY = e.touches[0].screenY; for touchmove\n\n  if (!isScrolling \u0026\u0026 currentY !== currentPageY) {\n    if (currentY \u003e currentPageY) {\n      scrollDirection = -1;\n    }\n    if (currentY \u003c currentPageY) {\n      scrollDirection = 1;\n    }\n    isScrolling = true;\n    window.requestAnimationFrame(scrollTo);\n  }\n};"},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Get scroll height"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"First, prepare a scroller element. The scroller should contain all of the contents, and the height should be 100% of the visible area height."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"For PC, this is easy: set the scroller's height (and all of its ancestors') to "},{"type":"textBody","style":"code","value":"100vh"},{"type":"textBody","style":"plain","value":", then get "},{"type":"textBody","style":"code","value":"window.innerHeight"},{"type":"textBody","style":"plain","value":", and we should be good. But for mobile devices, we have to deal with the problem that the browser address bar might hide during scrolling, which causes the visible area height to be inconsistent."}]},{"type":"paragraph","body":[{"type":"link","body":[{"type":"textBody","style":"plain","value":"The URL bar hides when the root element scrolls down"}],"url":"https://github.com/bokand/root-scroller/blob/master/explainer.md"},{"type":"textBody","style":"plain","value":", in which the root element means the "},{"type":"textBody","style":"code","value":"\u003chtml\u003e"},{"type":"textBody","style":"plain","value":" element. Therefore, to avoid URL bar hides during scrolling, it is necessary to prevent root element from scrolling while scrolling the contents."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"According to the "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"standard CSS overflow definition"}],"url":"https://www.w3.org/TR/CSS2/visufx.html#overflow"},{"type":"textBody","style":"plain","value":", by default both "},{"type":"textBody","style":"code","value":"\u003chtml\u003e"},{"type":"textBody","style":"plain","value":" and "},{"type":"textBody","style":"code","value":"\u003cbody\u003e"},{"type":"textBody","style":"plain","value":" has "},{"type":"textBody","style":"code","value":"overflow: auto"},{"type":"textBody","style":"plain","value":". Set both to "},{"type":"textBody","style":"code","value":"overflow: hidden"},{"type":"textBody","style":"plain","value":" , and we locked up "},{"type":"textBody","style":"code","value":"\u003chtml\u003e"},{"type":"textBody","style":"plain","value":" and "},{"type":"textBody","style":"code","value":"\u003cbody\u003e"},{"type":"textBody","style":"plain","value":" for good."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"The next step is to give the scroller "},{"type":"textBody","style":"code","value":"overflow: scroll"},{"type":"textBody","style":"plain","value":". Now when you scroll the viewport, "},{"type":"textBody","style":"code","value":"\u003chtml\u003e"},{"type":"textBody","style":"plain","value":" and "},{"type":"textBody","style":"code","value":"\u003cbody\u003e"},{"type":"textBody","style":"plain","value":" don't move at all, only the scroller is scrolling, and the URL bar will not hide. Notice that if there are any container elements between the scroller and the body, their overflow values also need to be "},{"type":"textBody","style":"code","value":"hidden"},{"type":"textBody","style":"plain","value":"."}]},{"type":"code","lang":"css","body":"html {\n  height: 100vh;\n  overflow-y: hidden;\n}\n\nbody {\n  height: 100%;\n  overflow-y: hidden;\n}\n\n.scroller {\n  height: 100%;\n  overflow-y: scroll;\n}"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"The visible area height should be consistent now, and we should get window height without too much trouble."}]},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Smooth scrolling"}]},{"type":"paragraph","body":[{"type":"textBody","style":"code","value":".scrollTo"},{"type":"textBody","style":"plain","value":" is initiative and efficient, but it's not very reliable. I've encountered scenarios that it wouldn't work (no effect at all). I haven't discovered the root cause, but it feels like "},{"type":"textBody","style":"code","value":".scrollTo"},{"type":"textBody","style":"plain","value":" gets canceled when called too frequently."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"I gave up the one-liner and went for another approach: "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"window.requestAnimationFrame"}],"url":"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"},{"type":"textBody","style":"plain","value":". This function prepares a frame to execute all the things inside the callback. This approach is inspired by "},{"type":"link","body":[{"type":"textBody","style":"plain","value":"vue-scrollto"}],"url":"https://github.com/rigor789/vue-scrollto"},{"type":"textBody","style":"plain","value":"."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"The callback has a single argument timestamp: "},{"type":"textBody","style":"code","value":"DOMHighResTimeStamp"},{"type":"textBody","style":"plain","value":", which is essentially a number. When scroll animation starts, save the initial timestamp and then compare the timestamp in each call with the initial timestamp to determine if the elapsed time has exceeded the designated scroll animation duration. If the scroll is not finished yet, call "},{"type":"textBody","style":"code","value":"window.requestAnimationFrame"},{"type":"textBody","style":"plain","value":" inside the callback recursively."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"For the scroll effect, set the scroller's scrollTop directly."}]},{"type":"paragraph","body":[{"type":"textBody","style":"code","value":"scroller.scrollTop = {the y position after each scroll step}"}]},{"type":"paragraph","body":[{"type":"textBody","style":"code","value":"scroll-behavior: \"smooth\""},{"type":"textBody","style":"plain","value":" doesn't apply when changing a div's "},{"type":"textBody","style":"code","value":"scrollTop"},{"type":"textBody","style":"plain","value":" value in this way; this is why we need to use "},{"type":"textBody","style":"code","value":"requestAnimationFrame"},{"type":"textBody","style":"plain","value":" to create an animation."}]},{"type":"code","lang":"js","body":"let scrollDuration;\nlet scrollDirection; // 1 or -1\nlet scrollStartTime;\nlet scroller;\nlet currentY;\nlet scrollDistance; // window height, likely 100vh\nlet isScrolling;\n\nconst scrollTo = (timestamp: DOMHighResTimeStamp) =\u003e {\n  if (!scrollStartTime) {\n    scrollStartTime = timestamp;\n  }\n\n  const elapsedTime = timestamp - scrollStartTime;\n  const progress = Math.min(elapsedTime / scrollDuration, 1);\n  scroller.scrollTop = currentY + scrollDistance * progress * scrollDirection;\n\n  if (elapsedTime \u003c duration) {\n    window.requestAnimationFrame(scrollTo);\n  } else {\n    currentY = scroller.scrollTop;\n    scrollStartTime = undefined;\n    scrollDirection = undefined;\n    isScrolling = false;\n  }\n};"},{"type":"heading","level":2,"body":[{"type":"textBody","style":"plain","value":"Remove the momentum"}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"When the user scrolls the screen hence triggers the "},{"type":"textBody","style":"code","value":"scroll"},{"type":"textBody","style":"plain","value":" or "},{"type":"textBody","style":"code","value":"touchmove"},{"type":"textBody","style":"plain","value":" event, it's unlikely that the event only fires once. We can have the conditioning to prevent our full-screen scroll from repeatedly called, but the other scrolls caused by the user's finger remains, even after the full-screen scroll finishes. Removing the scroll momentum is the necessary polishing for the full-screen scroll effect."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"There are two ways to disable scroll temporarily: "},{"type":"textBody","style":"code","value":"pointerEvent: none"},{"type":"textBody","style":"plain","value":", and —you might have guessed it— "},{"type":"textBody","style":"code","value":"overflow: hidden"},{"type":"textBody","style":"plain","value":". I found overflow more reliable, for "},{"type":"textBody","style":"code","value":"pointerEvent"},{"type":"textBody","style":"plain","value":" didn't work in some "},{"type":"textBody","style":"code","value":"touchmove"},{"type":"textBody","style":"plain","value":" scenario."}]},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"When the scroll starts (calling "},{"type":"textBody","style":"code","value":"window.requestAnimationFrame"},{"type":"textBody","style":"plain","value":" for the first time), add the above CSS property to the scroller element, and all the scrolls that after the first callback should take no effect. Thus we removed the momentum successfully."}]},{"type":"thematicBreak"},{"type":"paragraph","body":[{"type":"textBody","style":"plain","value":"I finished the full-screen scroll effect with the above approach. It works fine in macOS, win, and mobile platforms. I believe there are other ways to do this, but I'm quite happy with the result I came up with."}]}],"postMetadata":{"id":"full-screen-scroll","title":"Full-Screen Scroll","description":"Research notes of implementing full-screen scroll animation.","category":"research","topic":"web development","tags":[],"publishDate":"2021-02-11","pathname":"full-screen-scroll"},"last5posts":[{"id":"observation-on-programming-with-ai","title":"Observation on Programming with AI","description":"I reckoned getting familiar with AI coding tools is necessary, tried some, and to my surprise, I turned out to be quite optimistic.","category":"essay","topic":"programming","tags":[],"publishDate":"2025-03-13","pathname":"observation-on-programming-with-ai"},{"id":"blogging-and-digital-gardening","title":"Blogging and Digital Gardening in the Social Platform and Generative AI Era","description":"I talk to myself about why bother writing at somewhere nobody comes.","category":"essay","topic":"life","tags":[],"publishDate":"2025-02-11","pathname":"blogging-and-digital-gardening"},{"id":"a-redemption-three-years-later","title":"A Redemption Three Years Later","description":"CD PROJEKT RED made a promise about Night City, which they broke. Three years later they had another attempt, and to me, it was their redemption.","category":"review","topic":"gaming","tags":[],"publishDate":"2025-01-13","pathname":"a-redemption-three-years-later"},{"id":"s14-recap","title":"S14 Recap","description":"I did not play a lot of league during 2024, but I had a few unforgettable moments nonetheless.","category":"retrospective","topic":"gaming","tags":[],"publishDate":"2025-01-07","pathname":"s14-recap"},{"id":"thoughts-on-building-a-game-with-xstate","title":"Thoughts on Building a Game with XState","description":"After hearing about XState's good reputation for years, I used it to build the prototype for my game. These are my thoughts.","category":"note","topic":"game development","tags":[],"publishDate":"2025-01-04","pathname":"thoughts-on-building-a-game-with-xstate"}],"categoryPosts":[{"id":"under-the-hood-diablo-ii-item-generation","title":"Under the Hood: Diablo II Item Generation","description":"A system design research turned into a reconciliation with a game I didn't know I was so in love with, so I wrote a research note to express my appreciation.","category":"research","topic":"game development","tags":[],"publishDate":"2024-11-08","pathname":"under-the-hood-diablo-ii-item-generation"},{"id":"nextjs-app-font-not-loaded-on-remote-machine-issue","title":"Next.js App Font Not Loaded on Remote Machine Issue","description":"Debugging note of a source loading issue that never reproduces on the dev machine.","category":"research","topic":"web development","tags":[],"publishDate":"2023-06-05","pathname":"nextjs-app-font-not-loaded-on-remote-machine-issue"}],"categories":[{"name":"essay","count":13},{"name":"review","count":15},{"name":"retrospective","count":15},{"name":"note","count":9},{"name":"research","count":3}]},"__N_SSG":true},"page":"/blog/[pathname]","query":{"pathname":"full-screen-scroll"},"buildId":"K8ZbhF-RP2WBtco10lfGC","isFallback":false,"gsp":true,"scriptLoader":[]}</script><script>(function(){var el=document.createElement('link');el.href='/subfont/fallback-6d661b96db.css';el.rel='stylesheet';document.body.appendChild(el)}())</script><noscript><link rel="stylesheet" href="/subfont/fallback-6d661b96db.css"></noscript></body></html>